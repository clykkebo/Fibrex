---
title: "Fibrex Microbiome description"
author: "caly"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    toc_depth: 4
    collapsed: false
    code_folding: hide
    number_sections: false
knit: (function(inputFile, encoding) { 
    rmarkdown::render(
        inputFile, encoding = encoding,
        output_dir = file.path(dirname(inputFile),"output"),
        output_file = paste0("Fibrex_", Sys.Date(), "_beta_diversity.html"))
        })
params:
    input: "R_objects/Phyloseq.Rdata"
    group_var: "feed_treat"
    subject_var: "rat_name"
    time_var: "day"
    COL: !r c("A_CTRL" = "#a5cee3","A_PFOS" = "#1778b6","B_CTRL" = "#b4d88a","B_PFOS" = "#30a148") # based on feed_treat and colorscheme from scale_color_brewer(palette = "Paired")

---

# INFO

This template is build to use the output from **GMH_import** as input. It will take you through a basic beta diversity analysis for the project. Beta diversity is the difference between samples, this means that we compare samples as a whole. The analysis generally consists of three steps:

1.  Calculation of distance/dissimilarity between samples.

2.  Visualization of the data (ordination).

3.  Statistical analysis (PERMANOVA. ANOSIM, ...).

For each steps your choices will impact the interpretation of the output. This will be expanded in each section.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(GMHmicrobiome)
library(ggpubr)
library(kableExtra)
library(phyloseq)
library(cowplot)
library(ggExtra)
library(vegan)

# save parameters
saveRDS(params, "R_objects/params_betadiv.RDS")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

## PROJECT

The FIBREX project is a PFOS exposure experiment focusing on the difference in uptake and wash-out of PFOS between rats given feed with and without dietary fibers. Samples for this analysis are 16S rRNA V3 amplicons from extracted total DNA of feces and luminal samples from ileum and cecum. Fecal samples were collected before exposure start (day 0, n=48) and hereafter at day 8 (n=48), 12 (n=24), 16 (n=24), 20 (n=24) and 21 (n=24). Luminal contents were collected at dissections at day 8 (n=24) and 21 (n=24). DNA was sequenced on Illumina platform and raw data converted to ASVs using cutadapt (Martin 2011) and DADA2 (Callahan et al. 2016) and made into Phyloseq elements (McMurdie and Holmes 2013). Goal of the analysis is to investigate the impact of feed, PFOS exposure and time on the gut microbiota.

Sample data added from metadata contains results from:

Carmine treatment (0 = no and 1 = yes) for different days.

Bodyweight per sampling day (day 0, 8, 12, 16, 20 and 21), and cecum and liver weight per dissection day (day 8 and 21).

PFOS quantification of:

\- systemic concentrations in blood serum from day 8, 16 and 21, liver and brain tissues (day 8 and 21).

\- wash-out concentrations in urine from day 8, 16 and 21, feces from day 8, 12, 16 and 21, and cecum (day 8 and 21).

Short-chain fatty acids quantification of 10 compounds in cecum given in mM per dissection day (day 8 and 21).

pH-values from upper and lower jejunum, ileum and cecum in separate columns: pH_je_up, pH_je_low, pH_il, pH_ce per day. Also one pH column "pH" with values fitting each sample type (feces are assigned cecum values).

Transit time for each day (day 0 = measurement from day 0; day 8 = measurement from day 7; day 21 = measurement from day 20)

## VARIABLES

Group variable is set for "feed_treat" which is a combined variable in the format e.g. "A_CTRL" or "B_PFOS" grouping based on:
- type of feed (A = no dietary fiber and B = dietary fiber)
- type of treatment given by oral gavage daily for 7 days (CTRL = control with pure corn oil; PFOS = 1.5mg/mL PFOS in corn oil)

Subject variable is set to "rat_name" in the format R01 - R48.

Time variable is set to "day" which includes days of sampling (day 0 = feces before treatment; day 8 = feces directly after treatment from all rats and ileum+cecum from half the rats; day 12 and 16 = 21)

As mentioned, samples originate from both feces, cecum and ileum. These are reflected in the variable "material" as "Feces", "Cecum" and "Ileum". 

Unique sample names (Sample_ID) are a combined nomenclature of material, day and rat_name in that order, e.g. cecum from rat 14 on day 8 = C8R14, feces from rat 31 on day 12 = F12R31, ileum from rat 11 on day 21 = Il21R11. 

Note: nomenclature in "Sample_ID" was wrongly assigned  ileum and cecum for rat_names R41-R44, as R41 and R42 were taken on day 21 and R43 and R44 were taken on day 8. This is corrected in the columns "day" and "materialdayrat". The latter can be used for corrected sample nomenclature if needed.

# CALCULATE DISTANCES

## PREPARE DATA

First step is to create a clean phyloseq object (remove samples missing relevant data and/or subset by a relevant variable).

Beta diversity are affected by all samples included, so if some samples are removed, this should preferably be done before the beta diversity is calculated. \> qualitative metrics are sensitive to sequencing depth, so rarefaction should be done for those metrics as well.

```{r}

# Load data
params <- readRDS("R_objects/params_betadiv.RDS")
load(params$input)

# Create subset
phy.clean <- subset_samples(phy, material == "Feces")

# Clean data
phy.clean <- prune_samples(sample_names(phy.clean)[!is.na(sample_data(phy.clean)[,params$group_var])], phy.clean)

# Remove empty taxa
phy.clean <- prune_taxa(taxa_sums(phy.clean) > 0, phy.clean)

# Recalculate midpoint root
phy_tree(phy.clean) <- phangorn::midpoint(phy_tree(phy.clean))

# Perform multiple rarefactions
phy.rare <- multiple_rarefy(phy.clean)

# Remove empty taxa
phy.rare <- prune_taxa(taxa_sums(phy.rare) > 0, phy.rare)

# Recalculate midpoint root
phy_tree(phy.rare) <- phangorn::midpoint(phy_tree(phy.rare))

# Save object
save(phy.rare, phy.clean, file = "R_objects/Phyloseq_betadiv.Rdata")

# clear the environment and release memory
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
invisible(gc()) #free up memory and report the memory usage.
```

## CALCULATE

There are many different algorithms that can be used to calculate beta diversity. Each metric has its own advantages and many times a comparison of the results from two metrics tells more about the data than each one separately. I will include phylogeny based (UniFrac and weighted UniFrac), qualitative (presence/absence), quantitative (abundance based), and compositional (Aitchison) metrics in this template

### UNWEIGHTED UNIFRAC

The unique fraction metric, or UniFrac, measures the phylogenetic distance between sets of taxa in a phylogenetic tree as the fraction of the branch length of the tree that leads to descendants from either one environment or the other, but not both [(Lozupone & Knight, 2005)](https://doi.org/10.1128/AEM.71.12.8228-8235.2005). This metric is sensitive to sequencing depth, so it is required to use a rarefied phyloseq object The UniFrac algorithm requires a rooted tree, so if ASVs has been removed from the raw da the tree should be rerooted manually, else a random ASV will be chosen as root.

```{r calc-unif, eval=FALSE, echo=TRUE}

# load
params <- readRDS("R_objects/params_betadiv.RDS")
load("R_objects/Phyloseq_betadiv.Rdata")

# Calculate UniFrac distances
unif.dist <- UniFrac(phy.rare, weighted = FALSE, parallel = FALSE)

# Calculate PCoA data
unif.pcoa <- ordinate(phy.rare, method = "PCoA",distance = unif.dist)
unif.nmds <- metaMDS(unif.dist, k = 5, trymax = 1000)

# Save distance objects
save(unif.dist, unif.nmds, unif.pcoa, phy.rare, file = "R_objects/bdiv_unif.RData")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### WEIGHTED UNIFRAC

The unique fraction metric, or UniFrac, measures the phylogenetic distance between sets of taxa in a phylogenetic tree as the fraction of the branch length of the tree that leads to descendants from either one environment or the other, but not both [(Lozupone & Knight, 2005)](https://doi.org/10.1128/AEM.71.12.8228-8235.2005). Weighted UniFrac takes the abundance of each ASV into account instead of just presence/absence, which means that it will not be sensitive to sequencing depth. The UniFrac algorithm requires a rooted tree, so if ASVs has been removed from the raw da the tree should be rerooted manually, else a random ASV will be chosen as root.

```{r calc-wunif, eval=FALSE, echo=TRUE}

# load
params <- readRDS("R_objects/params_betadiv.RDS")
load("R_objects/Phyloseq_betadiv.Rdata")

# Calculate UniFrac distances
wuf.dist <- UniFrac(phy.clean, weighted = TRUE, parallel = FALSE)

# Calculate PCoA data
wuf.pcoa <- ordinate(phy.clean, method = "PCoA",distance = wuf.dist)
wuf.nmds <- metaMDS(wuf.dist, k = 5, trymax = 1000)

# Save distance objects
save(wuf.dist, wuf.nmds, wuf.pcoa, phy.clean, file = "R_objects/bdiv_wunif.RData")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### BRAY-CURTIS

Bray-Curtis dissimilarity index (as implemented by the vegan package) is the sum of abundance difference for each species/ASV, divided by theoretical maximum difference between the samples if no ASV overlapped. The formula used is: $$d_{jk} = \frac{\sum|n_{ij}-n_{ik}|}{\sum(n_{ij}+n_{ik})}$$ Bray-Curtis dissimilarity is not a true distance metric as it does not adhere to the [triangle inequality](https://en.wikipedia.org/wiki/Triangle_inequality), but is often used to compare microbiomes. Bray-Curtis dissimilarities are based on the assumption that measurements are taken from equal areas, so differences in total counts between samples will bias the metric. As differences in sequences depth is due to differences in the lab procedures and not biological differences, we should transform our counts to relative abundances before calculating Bray-Curtis dissimilarities. By transforming the data to abundances no data is lost, but rarefied data can also be used.

```{r calc-bray, eval=FALSE, echo=TRUE}

# load
params <- readRDS("R_objects/params_betadiv.RDS")
load("R_objects/Phyloseq_betadiv.Rdata")

# transform counts
phy.ra <- transform_sample_counts(phy.clean, function(x) x/sum(x))

# Calculate Bray-Curtis dissimilarities
bray.dist <- distance(phy.ra, method = "bray",)

# Calculate PCoA data
bray.pcoa <- ordinate(phy.ra, method = "PCoA",distance = bray.dist)
bray.nmds <- metaMDS(bray.dist, k = 5, trymax = 1000)

# Save distance objects
save(bray.dist, bray.nmds, bray.pcoa, phy.ra, file = "R_objects/bdiv_bray.RData")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### JACCARD

The Jaccard similarity measures the similarity between two sets of data to see which members are shared and distinct. The Jaccard similarity is calculated by dividing the number of observations in both sets by the number of observations in either set. In other words, the Jaccard similarity can be computed as the size of the intersection divided by the size of the union of two sets. This can be written in set notation using intersection $(A \cap B)$ and unions $(A \cup B)$ of two sets: $$J(A,B) = \frac{|A \cap B|}{|A \cup B|}$$ where $|A \cap B|$ gives the number of members shared between both sets and $|A \cup B|$ gives the total number of members in both sets (shared and un-shared). The Jaccard Similarity will be 0 if the two sets don't share any values and 1 if the two sets are identical.

Additionally, this function can be used to find the dissimilarity between two sets by calculating:
$$d(A,B) = 1 - J(A,B)$$
> We will be calculating binary Jaccard dissimilarity

```{r calc-jac, eval=FALSE, echo=TRUE}

# load
params <- readRDS("R_objects/params_betadiv.RDS")
load("R_objects/Phyloseq_betadiv.Rdata")

# Calculate Jaccard binary dissimilarities
jac.dist <- distance(phy.rare, method = "jaccard", binary = TRUE)

# Calculate PCoA data
jac.pcoa <- ordinate(phy.rare, method = "PCoA",distance = jac.dist)
jac.nmds <- metaMDS(jac.dist, k = 5, trymax = 1000)

# Save distance objects
save(jac.dist, jac.nmds, jac.pcoa, phy.rare, file = "R_objects/bdiv_jac.RData")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### AITCHISON

Aitchison distance (1986) and robust Aitchison distance [(Martino et al. 2019)](https://journals.asm.org/doi/10.1128/mSystems.00016-19) are metrics that deal with compositional data. The Aitchison distance is a dissimilarity measure calculated as the Euclidean distance between observations (samples) after performing a centered log ratio (“clr”) transformation. Aitchison distance has been said to outperform Jensen-Shannon divergence and Bray-Curtis dissimilarity, due to a better stability to subsetting and aggregation, and it being a proper distance (Aitchison et al., 2000).

```{r calc-ait, eval=FALSE, echo=TRUE}

# load
params <- readRDS("R_objects/params_betadiv.RDS")
load("R_objects/Phyloseq_betadiv.Rdata")

# Calculate Bray-Curtis dissimilarities
ait.dist <- vegan::vegdist(otu_table(phy.clean), method = "robust.aitchison")

# Calculate PCoA data
ait.pcoa <- ordinate(phy.clean, method = "PCoA",distance = ait.dist)
ait.nmds <- metaMDS(ait.dist, k = 5, trymax = 1000)

# Save distance objects
save(ait.dist, ait.nmds, ait.pcoa, phy.clean, file = "R_objects/bdiv_ait.RData")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### SUBSETS
```{r calc-unif, eval=FALSE, echo=TRUE}
METRICES <- c("bray","unif","wuf","jac","ait")
DAYS <- c("d0","d08","d12","d16","d20","d21")
FEEDS <- c("A","B","ALL")
MTRL <- "Feces"
# load
params <- readRDS("R_objects/params_betadiv.RDS")
load("R_objects/Phyloseq_betadiv.Rdata")
message("Running loop for calculation of beta diversity subsets for feces.")
for (DAY in DAYS) {
  print(paste0("Processing day ",DAY,"..."))
  for (FEED in FEEDS) {
    for (METRIC in METRICES) {
      load("R_objects/Phyloseq_betadiv.Rdata")
      if (FEED == "ALL") {
        FILENAME <- paste0("R_objects/bdiv_sub_",MTRL,"_",DAY,"_",METRIC,".Rdata")
      } else {
          FILENAME <- paste0("R_objects/bdiv_sub_",MTRL,"_",DAY,"_",FEED,"_",METRIC,".Rdata")
      }
      if (METRIC == "unif") {
        load("R_objects/bdiv_unif.RData")
        tmp.dist <- as.matrix(unif.dist)
        if (FEED == "ALL") {
          phy.sub <- subset_samples(phy.rare, material == MTRL & day %in% DAY)
        } else {
          phy.sub <- subset_samples(phy.rare, material == MTRL & day %in% DAY & feed %in% FEED)
        }
        SUBS <- sample_names(phy.sub)
        
        tmp.sub.dist <- tmp.dist[SUBS, SUBS]
        unif.sub.dist <- as.dist(tmp.sub.dist, diag = TRUE, upper = TRUE)
        
        unif.sub.pcoa <- ordinate(phy.sub, method = "PCoA",distance = unif.sub.dist)
        unif.sub.nmds <- metaMDS(unif.sub.dist, k = 5, trymax = 1000)
        
        save(phy.sub, unif.sub.dist, unif.sub.nmds, unif.sub.pcoa, file = FILENAME)
      } else if (METRIC == "wuf") {
        load("R_objects/bdiv_wunif.RData")
        tmp.dist <- as.matrix(wuf.dist)
        
        if (FEED == "ALL") {
          phy.sub <- subset_samples(phy.clean, material == MTRL & day %in% DAY)
        } else {
          phy.sub <- subset_samples(phy.clean, material == MTRL & day %in% DAY & feed %in% FEED)
        }
        SUBS <- sample_names(phy.sub)
        
        tmp.sub.dist <- tmp.dist[SUBS, SUBS]
        wuf.sub.dist <- as.dist(tmp.sub.dist, diag = TRUE, upper = TRUE)
        
        wuf.sub.pcoa <- ordinate(phy.sub, method = "PCoA",distance = wuf.sub.dist)
        wuf.sub.nmds <- metaMDS(wuf.sub.dist, k = 5, trymax = 1000)
        
        save(phy.sub, wuf.sub.dist, wuf.sub.nmds, wuf.sub.pcoa, file = FILENAME)
      } else if (METRIC == "bray") {
        load("R_objects/bdiv_bray.RData")
        tmp.dist <- as.matrix(bray.dist)
        
        if (FEED == "ALL") {
          phy.sub <- subset_samples(phy.rare, material == MTRL & day %in% DAY)
        } else {
          phy.sub <- subset_samples(phy.rare, material == MTRL & day %in% DAY & feed %in% FEED)
        }
        SUBS <- sample_names(phy.sub)
        
        tmp.sub.dist <- tmp.dist[SUBS, SUBS]
        bray.sub.dist <- as.dist(tmp.sub.dist, diag = TRUE, upper = TRUE)
        
        bray.sub.pcoa <- ordinate(phy.sub, method = "PCoA", distance = bray.sub.dist)
        bray.sub.nmds <- metaMDS(bray.sub.dist, k = 5, trymax = 1000)
        
        save(phy.sub, bray.sub.dist, bray.sub.pcoa, bray.sub.nmds, file = FILENAME)
      } else if (METRIC == "jac") {
        load("R_objects/bdiv_jac.RData")
        tmp.dist <- as.matrix(jac.dist)
        
        if (FEED == "ALL") {
          phy.sub <- subset_samples(phy.rare, material == MTRL & day %in% DAY)
        } else {
          phy.sub <- subset_samples(phy.rare, material == MTRL & day %in% DAY & feed %in% FEED)
        }
        SUBS <- sample_names(phy.sub)
        
        tmp.sub.dist <- tmp.dist[SUBS, SUBS]
        jac.sub.dist <- as.dist(tmp.sub.dist, diag = TRUE, upper = TRUE)
        
        jac.sub.pcoa <- ordinate(phy.sub, method = "PCoA", distance = jac.sub.dist)
        jac.sub.nmds <- metaMDS(jac.sub.dist, k = 5, trymax = 1000)
        
        save(phy.sub, jac.sub.dist, jac.sub.pcoa, jac.sub.nmds, file = FILENAME)
      } else if (METRIC == "ait") {
        load("R_objects/bdiv_ait.RData")
        tmp.dist <- as.matrix(ait.dist)
        
        if (FEED == "ALL") {
          phy.sub <- subset_samples(phy.clean, material == MTRL & day %in% DAY)
        } else {
          phy.sub <- subset_samples(phy.clean, material == MTRL & day %in% DAY & feed %in% FEED)
        }
        SUBS <- sample_names(phy.sub)
        
        tmp.sub.dist <- tmp.dist[SUBS, SUBS]
        ait.sub.dist <- as.dist(tmp.sub.dist, diag = TRUE, upper = TRUE)
        
        ait.sub.pcoa <- ordinate(phy.sub, method = "PCoA", distance = ait.sub.dist)
        ait.sub.nmds <- metaMDS(ait.sub.dist, k = 5, trymax = 1000)
        
        save(phy.sub, ait.sub.dist, ait.sub.pcoa, ait.sub.nmds, file = FILENAME)
      }
    }
  }
}
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```




# VISUALIZATION

Beta diversity is generally visualized by a NMDS (non metric multidimensional scaling) or PCoA (Principal Coordinate Analysis) plots. Both methods creates a representation of the beta diversity on few axes (3D plots should only be used for interactive on screen representations).


> REMEMBER that any interpretation of a plot **MUST** be supported by a statistical analysis

## LOAD DATA FROM SUBSETS
First step is to  load the data and define the which variable will be tested in the following blocks.

```{r load-betadiv-a, eval=TRUE, echo=TRUE}

params <- readRDS("R_objects/params_betadiv.RDS")

# Choose metric
METRIC <- "unif"

# Choose variable 
VAR <- "feed_treat"
MTRL <- "Feces"
DAY <- "d08"
FEED <- "A"

# Load data
if (FEED == "All") {
  BFILE <- paste0("R_objects/bdiv_sub_",MTRL,"_",DAY,"_",METRIC,".Rdata")
} else {
  BFILE <- paste0("R_objects/bdiv_sub_",MTRL,"_",DAY,"_",FEED,"_",METRIC,".Rdata")
}
if (METRIC == "unif") {
  load(BFILE)
  dist.used <- unif.sub.dist
  nmds.used <- unif.sub.nmds
  pcoa.used <- unif.sub.pcoa
  phy.used <- phy.sub
  rm(unif.sub.dist, unif.sub.nmds, unif.sub.pcoa, phy.sub)
} else if (METRIC == "wuf") {
  load(BFILE)
  dist.used <- wuf.sub.dist
  nmds.used <- wuf.sub.nmds
  pcoa.used <- wuf.sub.pcoa
  phy.used <- phy.sub
  rm(wuf.sub.dist, wuf.sub.nmds, wuf.sub.pcoa,phy.sub)
} else if (METRIC == "bray"){
  load(BFILE)
  dist.used <- bray.sub.dist
  nmds.used <- bray.sub.nmds
  pcoa.used <- bray.sub.pcoa
  phy.used <- phy.sub
  rm(bray.sub.dist, bray.sub.nmds, bray.sub.pcoa, phy.sub)
} else if (METRIC == "jac"){
  load(BFILE)
  dist.used <- jac.sub.dist
  nmds.used <- jac.sub.nmds
  pcoa.used <- jac.sub.pcoa
  phy.used <- phy.sub
  rm(jac.sub.dist, jac.sub.nmds, jac.sub.pcoa, phy.sub)
} else if (METRIC == "ait"){
  load(BFILE)
  dist.used <- ait.sub.dist
  nmds.used <- ait.sub.nmds
  pcoa.used <- ait.sub.pcoa
  phy.used <- phy.sub
  rm(ait.sub.dist, ait.sub.nmds, ait.sub.pcoa, phy.sub)
}


# if (METRIC == "unif") {
#   load("R_objects/bdiv_unif.RData")
#   dist.used <- unif.dist
#   nmds.used <- unif.nmds
#   pcoa.used <- unif.pcoa
#   phy.used <- phy.rare
#   rm(unif.dist, unif.nmds, unif.pcoa, phy.rare)
# } else if (METRIC == "wunif") {
#   load("R_objects/bdiv_wunif.RData")
#   dist.used <- wuf.dist
#   nmds.used <- wuf.nmds
#   pcoa.used <- wuf.pcoa
#   phy.used <- phy.clean
#   rm(wuf.dist, wuf.nmds, wuf.pcoa,phy.clean)
# } else if (METRIC == "bray"){
#   load("R_objects/bdiv_bray.RData")
#   dist.used <- bray.dist
#   nmds.used <- bray.nmds
#   pcoa.used <- bray.pcoa
#   phy.used <- phy.ra
#   rm(bray.dist, bray.nmds, bray.pcoa, phy.ra)
# } else if (METRIC == "jac"){
#   load("R_objects/bdiv_jac.RData")
#   dist.used <- bray.dist
#   nmds.used <- bray.nmds
#   pcoa.used <- bray.pcoa
#   phy.used <- phy.rare
#   rm(jac.dist, jac.nmds, jac.pcoa, phy.rare)
# } else if (METRIC == "ait"){
#   load("R_objects/bdiv_ait.RData")
#   dist.used <- ait.dist
#   nmds.used <- ait.nmds
#   pcoa.used <- ait.pcoa
#   phy.used <- phy.clean
#   rm(ait.dist, ait.nmds, ait.pcoa, phy.clean)
#}

# Extract metadata from phyloseq
mdat <- data.frame(sample_data(phy.used))

# If a variable consist of numbers, but represent distinct groups remember to make it into a factor
mdat[,VAR] <- as.factor(mdat[,VAR])
```

## CLEAN ORDINATION {.tabset .tabset-fade .tabset-pills}

The data from an ordination can be plotted in many different ways. Here I will look at the importance of each axis in the PCoA plot, perform standard 2D-ordination plots, and plot dispertion for each variable.

### EIGENVALUES

For PCoA each axis represent a specific amount of the overall variation in the dataset. this information can easily be extracted and plotted.

```{r plot-eigenvalues-a, eval=TRUE, echo=TRUE}

# Extract eigen values
eigen <- pcoa.used$values
eigen$Axis <- as.numeric(row.names(eigen))

# Create plots for both distance indeces
p.eigen <- ggplot(eigen[1:10,], aes(x = as.factor(Axis), y = 100*Relative_eig)) + 
  geom_col(aes(fill = as.factor(Axis))) +
  geom_point(aes(x = Axis, y = 100*Cumul_eig)) +
  geom_line(aes(x = Axis, y = 100*Cumul_eig)) +
  ylab("Variance explained (%)") +
  xlab("Axis") +
  theme_pubr(legend = "none") + ggsci::scale_fill_jco()
p.eigen + ggtitle(paste("Variance per axis for", METRIC, sep = " "))
suppressMessages(ggsave(plot = p.eigen, filename = paste0("plots/bdiv/",MTRL,"_",DAY,"/bdiv_PCoA_axis",METRIC,".png"), device = "png"))

```

### PLOT

Phyloseq has a plotting function, but it is a bit limited in some of the settings. Therefore, I recommend to use the function to create a table of the data and then make your own plots
The first plot highlights the location of each group on the first 5 axis. Based on this an optimal set of axis can be chosen for the following ordination plot.

```{r ordination-find-axis-a, eval=TRUE}
# Create plots of eigenvalues for PCoA plots
pcoa.tab <- plot_ordination(phy.used, pcoa.used,axes = 1:5,justDF = TRUE)
nmds.tab <- plot_ordination(phy.used, nmds.used,axes = 1:5,justDF = TRUE)

# Reformat tables to create one common table
colnames(nmds.tab)[1:5] <- c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5")

nmds.tab$ordination <- "nmds"
pcoa.tab$ordination <- "pcoa"

ord.tab <- rbind(nmds.tab,pcoa.tab)
ord.tab[,VAR] <- as.factor(ord.tab[,VAR])

# Melt axis to be in one variable
axis.tab <- pivot_longer(data = ord.tab, cols = c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5"), names_to = "Axis", values_to = "position")

# Plot positions on axes
ggplot(axis.tab, aes_string(x = "ordination", y = "position", fill = VAR)) +
  geom_boxplot() +
  facet_grid(Axis~.) +
  coord_flip() + 
  theme_pubr(legend = "bottom") + scale_fill_manual(values = params$COL)#ggsci::scale_fill_jco()
```

based on the best separation on the axis in the plot above I have chosen to use Axis 1 and 2 for the ordination

```{r plot-ordination-a, eval=TRUE}
# Create NMDS plot
plot.nmds <- ggplot(ord.tab[ord.tab$ordination == "nmds",], aes_string(x = "Axis.1", y = "Axis.2", color = VAR, group = VAR)) +
  geom_point() + 
  labs(color=VAR) +
  theme_pubr(legend = "bottom")+
  stat_ellipse() + scale_color_manual(values = params$COL)
plot.nmds1 <- plot.nmds + theme_pubr(legend = "none")
plot.nmds2 <- ggExtra::ggMarginal(p = plot.nmds1, type = 'boxplot', size = 10, groupFill = TRUE )

# Create PCoA plot
plot.pcoa <- ggplot(ord.tab[ord.tab$ordination == "pcoa",], aes_string(x = "Axis.1", y = "Axis.2", color = VAR, group = VAR)) +
  geom_point() + 
  theme_pubr(legend = "none") + 
  labs(color=VAR) +
  stat_ellipse() + scale_color_manual(values = params$COL)
plot.pcoa2 <- ggExtra::ggMarginal(p = plot.pcoa, type = 'boxplot', size = 10, groupFill = TRUE)

# Extract legend
plot.legend <- get_legend(plot.nmds)

# Draw plot
p.done <- ggdraw() + 
  draw_plot(plot.nmds2, 0, 0.1, 0.5, 0.9) + 
  draw_plot(plot.pcoa2, 0.5, 0.1, 0.5, 0.9) +
  draw_grob(plot.legend, 0, 0, 1, .1) +
  draw_plot_label("NMDS") + 
  draw_plot_label("PCoA", x = 0.5) + 
  theme(plot.background = element_rect(fill="white", color = NA))

p.done

# Save plot
plotfile <- file.path("plots",paste0("bdiv/",MTRL,"_",DAY,"/bdiv_ordination_",VAR,".png"))
ggsave(filename = plotfile, plot = p.done, width = 14, height = 7,units = "in",dpi = 300)

```


# STATISTICAL ANALYSIS

## PERMANOVA
The more important part of a beta diversity analysis is to determine if there are any statistical significant differences in the data.
To do this we will perform an **Permutational Multivariate Analysis of Variance Using Distance Matrices** using the vegan function `adonis2`.

`adonis2` is a function for the analysis and partitioning sums of squares using dissimilarities. The function is based on the principles of [McArdle & Anderson (2001)](https://doi.org/10.1890/0012-9658(2001)082[0290:FMMTCD]2.0.CO;2) and can perform sequential, marginal and overall tests. The function also allows using additive constants or squareroot of dissimilarities to avoid negative eigenvalues, but can also handle semimetric indices (such as Bray-Curtis) that produce negative eigenvalues. The `adonis2` tests are identical to `anova.cca` of `dbrda`. With Euclidean distances, the tests are also identical to `anova.cca` of `rda`.

The function partitions sums of squares of a multivariate data set, and they are directly analogous to MANOVA (multivariate analysis of variance). McArdle and Anderson (2001) and [Anderson (2001)](https://doi.org/10.1111/j.1442-9993.2001.01070.pp.x) refer to the method as “permutational MANOVA” (formerly “nonparametric MANOVA”). Further, as the inputs are linear predictors, and a response matrix of an arbitrary number of columns, they are a robust alternative to both parametric MANOVA and to ordination methods for describing how variation is attributed to different experimental treatments or uncontrolled covariates. The method is also analogous to distance-based redundancy analysis in functions `dbrda` and `capscale` [(Legendre and Anderson 1999)](https://doi.org/10.1890/0012-9615(1999)069[0001:DBRATM]2.0.CO;2), and provides an alternative to AMOVA (nested analysis of molecular variance, Excoffier, Smouse, and Quattro, 1992; `amova` in the ade4 package) for both crossed and nested factors.

> Anderson (2001, Fig. 4) warns that the method may confound location and dispersion effects: significant differences may be caused by different within-group variation (dispersion) instead of different mean values of the groups (see [Warton et al. 2012](https://doi.org/10.1111/j.2041-210X.2011.00127.x) for a general analysis). However, it seems that `adonis2` is less sensitive to dispersion effects than some of its alternatives (`anosim`, `mrpp`). Function `betadisper` is a sister function to `adonis2` to study the differences in dispersion within the same geometric framework.

### DISPERTION

First we will test the beta diversity dispertion to determine whether any differences in dispertion might cause any PERMANOVA differences.

```{r betadisp-a, eval=TRUE}

# Calculate betadispertion
bdisp <- betadisper(dist.used, mdat[,VAR])

# Run statical test
anova(bdisp)

# Run posthoc test if significant and more than two groups
TukeyHSD(bdisp)
plot(TukeyHSD(bdisp))

# Plot dispertion
boxplot(bdisp)

```

When plotting the TukeyHSD, the y-axis is terribly formatted, but ordered similarly to the written output.

> Any significant differences will increase the significance of the following PERMANOVA test, which should then be interpreted carefully.

### RUN TEST

> The formulation of the adonis2 test **MUST** be updated manually!

```{r permanova-a, eval=TRUE}

# Perform test
if (FEED == "All") {
  adonis2(dist.used ~ treatment*feed, data = mdat, strata = mdat$day, permutations = 999, na.action = na.omit)
} else {
adonis2(dist.used ~ treatment, data = mdat, strata = mdat$day, permutations = 999, na.action = na.omit)
}

```

## FIT VARIABLES TO ORDINATION

Another way to analyse the beta diversity is to fit the metadata variables to the ordinations, this is done with the \code{vegan} function `envfit`. This function will fit both quantitative and/or qualitative variables to the ordinations

### CALCULATION

First step is to perform the calculation

```{r envfit-calc-a, eval=TRUE}

# Fit data
fit.nmds <- envfit(nmds.used ~ dna_conc+feed+cecum_weight,mdat, na.rm=TRUE, perm = 999)
fit.pcoa <- envfit(nmds.used ~ dna_conc+feed+cecum_weight,mdat, na.rm=TRUE, perm = 999)

```

### FORMAT DATA

The `envfit` output is not formatted for ggplot, so we will have to do that ourselves

```{r envfit-format-a,eval=TRUE}
# Extract nmds arrows
arrow.nmds <- data.frame(fit.nmds$vectors$arrows)
colnames(arrow.nmds) <- c("xend","yend")
arrow.nmds$xend <- with(arrow.nmds, xend*sqrt(fit.nmds$vectors$r)*100)
arrow.nmds$yend <- with(arrow.nmds, yend*sqrt(fit.nmds$vectors$r)*100)

# Extract pcoa arrows
arrow.pcoa <- data.frame(fit.pcoa$vectors$arrows)
colnames(arrow.pcoa) <- c("xend","yend")
arrow.pcoa$xend <- with(arrow.pcoa, xend*sqrt(fit.pcoa$vectors$r)*100)
arrow.pcoa$yend <- with(arrow.pcoa, yend*sqrt(fit.pcoa$vectors$r)*100)

# extract nmds centroids
center.nmds <- as.data.frame(fit.nmds$factors$centroids) %>% 
  rownames_to_column(var = "treatment") %>% 
  mutate(treatment = str_remove(treatment, "treatment"), ordination = "nmds")
colnames(center.nmds) <- c("treatment","center.x","center.y","ordination")

# extract pcoa centroids
center.pcoa <- as.data.frame(fit.pcoa$factors$centroids) %>%
  rownames_to_column(var = "treatment") %>% 
  mutate(treatment = str_remove(treatment, "treatment"), ordination = "pcoa")
colnames(center.pcoa) <- c("treatment","center.x","center.y","ordination")

# cobine 
center.dat <- rbind(center.nmds,center.pcoa)

# add data to ord
ord.tab.2 <- full_join(ord.tab,center.dat)

```
### PLOT

With the variables fitted to the ordination, we can now create the plot

```{r envfit-plot-a, eval=TRUE}

# Create NMDS plot
plot.nmds <- ggplot(ord.tab.2[ord.tab.2$ordination == "nmds",], aes_string(x = "Axis.1", y = "Axis.2", color = VAR)) +
  geom_point() + 
  labs(color=VAR) +
  theme_pubr(legend = "bottom")+
  geom_segment(aes(xend = center.x,yend = center.y)) +
  geom_segment(data = arrow.nmds, 
               aes(x = 0, y = 0, xend = xend, yend = yend, color = NULL), 
               arrow = arrow(type = "closed", length = unit(0.1, "inches")),
               show.legend = FALSE) + 
  geom_text(data = arrow.nmds, 
            aes(x = xend, y = yend, label = row.names(arrow.nmds), color = NULL), 
            nudge_x = 2, nudge_y = 2,
            show.legend = F) +
  ggsci::scale_color_jco()
plot.nmds1 <- plot.nmds + theme_pubr(legend = "none")
plot.nmds2 <- ggExtra::ggMarginal(p = plot.nmds1, type = 'boxplot', size = 10, groupFill = TRUE )

# Create PCoA plot
plot.pcoa <- ggplot(ord.tab.2[ord.tab.2$ordination == "pcoa",], aes_string(x = "Axis.1", y = "Axis.2", color = VAR)) +
  geom_point() + 
  theme_pubr(legend = "none") + 
  labs(color=VAR) +
  geom_segment(aes(xend = center.x,yend = center.y)) +
  geom_segment(aes(x = 0, y = 0, xend = xend, yend = yend, color = NULL), 
               data = arrow.nmds, 
               arrow = arrow(type = "closed", length = unit(0.1, "inches")),
               show.legend = FALSE) + 
  geom_text(data = arrow.nmds, 
            aes(x = xend, y = yend, label = row.names(arrow.nmds), color = NULL), 
            nudge_x = 2, nudge_y = 2,
            show.legend = F) +
  #stat_ellipse() + 
  ggsci::scale_color_jco()
plot.pcoa2 <- ggExtra::ggMarginal(p = plot.pcoa, type = 'boxplot', size = 10, groupFill = TRUE)

# Draw plot
p.done <- ggdraw() + 
  draw_plot(plot.nmds2, 0, 0.1, 0.5, 0.9) + 
  draw_plot(plot.pcoa2, 0.5, 0.1, 0.5, 0.9) +
  draw_grob(plot.legend, 0, 0, 1, .1) +
  draw_plot_label("NMDS") + 
  draw_plot_label("PCoA", x = 0.5) + 
  theme(plot.background = element_rect(fill="white", color = NA))
p.done

# Save plot
plotfile <- file.path("plots",paste0("bdiv_ordination_annotated_",VAR,".png"))
ggsave(filename = plotfile, plot = p.done, width = 14, height = 7,units = "in",dpi = 300)

```

# LOOP VISUALIZATION
```{r loop-betadiv-a, eval=TRUE, echo=TRUE}

params <- readRDS("R_objects/params_betadiv.RDS")

# Choose metric
METRIC <- "bray"

# Choose variable 
VAR <- "feed_treat"
MTRL <- "Feces"
DAY <- "d08"
FEED <- "A"

METRICES <- c("bray","unif","wuf","jac","ait")
DAYS <- c("d0","d08","d12","d16","d20","d21")
FEEDS <- c("A","B","ALL")
MTRL <- "Feces"


# Load data
for (DAY in DAYS) {
  print(paste0("Processing day ",DAY,"..."))
  for (FEED in FEEDS) {
    for (METRIC in METRICES) {
if (FEED == "ALL") {
  BFILE <- paste0("R_objects/bdiv_sub_",MTRL,"_",DAY,"_",METRIC,".Rdata")
} else {
  BFILE <- paste0("R_objects/bdiv_sub_",MTRL,"_",DAY,"_",FEED,"_",METRIC,".Rdata")
}
if (METRIC == "unif") {
  load(BFILE)
  dist.used <- unif.sub.dist
  nmds.used <- unif.sub.nmds
  pcoa.used <- unif.sub.pcoa
  phy.used <- phy.sub
  rm(unif.sub.dist, unif.sub.nmds, unif.sub.pcoa, phy.sub)
} else if (METRIC == "wuf") {
  load(BFILE)
  dist.used <- wuf.sub.dist
  nmds.used <- wuf.sub.nmds
  pcoa.used <- wuf.sub.pcoa
  phy.used <- phy.sub
  rm(wuf.sub.dist, wuf.sub.nmds, wuf.sub.pcoa,phy.sub)
} else if (METRIC == "bray"){
  load(BFILE)
  dist.used <- bray.sub.dist
  nmds.used <- bray.sub.nmds
  pcoa.used <- bray.sub.pcoa
  phy.used <- phy.sub
  rm(bray.sub.dist, bray.sub.nmds, bray.sub.pcoa, phy.sub)
} else if (METRIC == "jac"){
  load(BFILE)
  dist.used <- jac.sub.dist
  nmds.used <- jac.sub.nmds
  pcoa.used <- jac.sub.pcoa
  phy.used <- phy.sub
  rm(jac.sub.dist, jac.sub.nmds, jac.sub.pcoa, phy.sub)
} else if (METRIC == "ait"){
  load(BFILE)
  dist.used <- ait.sub.dist
  nmds.used <- ait.sub.nmds
  pcoa.used <- ait.sub.pcoa
  phy.used <- phy.sub
  rm(ait.sub.dist, ait.sub.nmds, ait.sub.pcoa, phy.sub)
}
print(paste0("- ",FEED," for ",METRIC,"..."))
# Extract metadata from phyloseq
mdat <- data.frame(sample_data(phy.used))

# If a variable consist of numbers, but represent distinct groups remember to make it into a factor
mdat[,VAR] <- as.factor(mdat[,VAR])

# Extract eigen values
eigen <- pcoa.used$values
eigen$Axis <- as.numeric(row.names(eigen))

# Create plots for both distance indeces
p.eigen <- ggplot(eigen[1:10,], aes(x = as.factor(Axis), y = 100*Relative_eig)) + 
  geom_col(aes(fill = as.factor(Axis))) +
  geom_point(aes(x = Axis, y = 100*Cumul_eig)) +
  geom_line(aes(x = Axis, y = 100*Cumul_eig)) +
  ylab("Variance explained (%)") +
  xlab("Axis") +
  theme_pubr(legend = "none") + ggsci::scale_fill_jco()
try(p.eigen + ggtitle(paste("Variance per axis for", METRIC, sep = " ")), silent = TRUE)
try(suppressMessages(ggsave(plot = p.eigen, filename = paste0("plots/bdiv/",MTRL,"_",DAY,"/bdiv_PCoA_axis_",FEED,"_",METRIC,".png"), device = "png")), silent = TRUE)

# Create plots of eigenvalues for PCoA plots
pcoa.tab <- plot_ordination(phy.used, pcoa.used,axes = 1:5,justDF = TRUE)
nmds.tab <- plot_ordination(phy.used, nmds.used,axes = 1:5,justDF = TRUE)

# Reformat tables to create one common table
colnames(nmds.tab)[1:5] <- c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5")

nmds.tab$ordination <- "nmds"
pcoa.tab$ordination <- "pcoa"

ord.tab <- rbind(nmds.tab,pcoa.tab)
ord.tab[,VAR] <- as.factor(ord.tab[,VAR])

# Melt axis to be in one variable
axis.tab <- pivot_longer(data = ord.tab, cols = c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5"), names_to = "Axis", values_to = "position")

# Plot positions on axes
ggplot(axis.tab, aes_string(x = "ordination", y = "position", fill = VAR)) +
  geom_boxplot() +
  facet_grid(Axis~.) +
  coord_flip() + 
  theme_pubr(legend = "bottom") + scale_fill_manual(values = params$COL)#ggsci::scale_fill_jco()

# Create NMDS plot
plot.nmds <- ggplot(ord.tab[ord.tab$ordination == "nmds",], aes_string(x = "Axis.1", y = "Axis.2", color = VAR, group = VAR)) +
  geom_point() + 
  labs(color=VAR) +
  theme_pubr(legend = "bottom")+
  stat_ellipse() + scale_color_manual(values = params$COL)
plot.nmds1 <- plot.nmds + theme_pubr(legend = "none")
plot.nmds2 <- ggExtra::ggMarginal(p = plot.nmds1, type = 'boxplot', size = 10, groupFill = TRUE )

# Create PCoA plot
plot.pcoa <- ggplot(ord.tab[ord.tab$ordination == "pcoa",], aes_string(x = "Axis.1", y = "Axis.2", color = VAR, group = VAR)) +
  geom_point() + 
  theme_pubr(legend = "none") + 
  labs(color=VAR) +
  stat_ellipse() + scale_color_manual(values = params$COL)
plot.pcoa2 <- ggExtra::ggMarginal(p = plot.pcoa, type = 'boxplot', size = 10, groupFill = TRUE)

# Extract legend
plot.legend <- get_legend(plot.nmds)

# Draw plot
p.done <- ggdraw() + 
  draw_plot(plot.nmds2, 0, 0.1, 0.5, 0.9) + 
  draw_plot(plot.pcoa2, 0.5, 0.1, 0.5, 0.9) +
  draw_grob(plot.legend, 0, 0, 1, .1) +
  draw_plot_label("NMDS") + 
  draw_plot_label("PCoA", x = 0.5) + 
  theme(plot.background = element_rect(fill="white", color = NA))

p.done

# Save plot
plotfile <- file.path("plots",paste0("bdiv/",MTRL,"_",DAY,"/bdiv_ordination_",VAR,"_",FEED,"_",METRIC,".png"))
ggsave(filename = plotfile, plot = p.done, width = 14, height = 7,units = "in",dpi = 300, device = "png")
plotfile <- file.path("plots",paste0("bdiv/",MTRL,"_",DAY,"/bdiv_ordination_",VAR,"_",FEED,"_",METRIC,".pdf"))
ggsave(filename = plotfile, plot = p.done, width = 14, height = 7,units = "in",dpi = 300, device = "pdf")

# Calculate betadispertion
bdisp <- betadisper(dist.used, mdat[,VAR])

# Run statical test
anova(bdisp)

# Run posthoc test if significant and more than two groups
TukeyHSD(bdisp)
plot(TukeyHSD(bdisp))

# Plot dispertion
boxplot(bdisp)

# Perform test
if (FEED == "All") {
  PERM <- adonis2(dist.used ~ treatment*feed, data = mdat, strata = mdat$day, permutations = 999, na.action = na.omit)
} else {
  PERM <- adonis2(dist.used ~ treatment, data = mdat, strata = mdat$day, permutations = 999, na.action = na.omit)
}
write.table(PERM, file = paste0("plots/bdiv/",MTRL,"_",DAY,"/bdiv_PERM_",VAR,"_",FEED,"_",METRIC,".txt"))
    }
  }
  print(paste0("Finished day ",DAY,"..."))
}
```

```{r envfit-calc-a, eval=TRUE}

# Fit data
fit.nmds <- envfit(nmds.used ~ treatment+feed,mdat, na.rm=TRUE, perm = 999)
fit.pcoa <- envfit(nmds.used ~ treatment+feed,mdat, na.rm=TRUE, perm = 999)

```

```{r envfit-format-a,eval=TRUE}
# Extract nmds arrows
arrow.nmds <- data.frame(fit.nmds$vectors$arrows)
colnames(arrow.nmds) <- c("xend","yend")
arrow.nmds$xend <- with(arrow.nmds, xend*sqrt(fit.nmds$vectors$r)*100)
arrow.nmds$yend <- with(arrow.nmds, yend*sqrt(fit.nmds$vectors$r)*100)

# Extract pcoa arrows
arrow.pcoa <- data.frame(fit.pcoa$vectors$arrows)
colnames(arrow.pcoa) <- c("xend","yend")
arrow.pcoa$xend <- with(arrow.pcoa, xend*sqrt(fit.pcoa$vectors$r)*100)
arrow.pcoa$yend <- with(arrow.pcoa, yend*sqrt(fit.pcoa$vectors$r)*100)

# extract nmds centroids
center.nmds <- as.data.frame(fit.nmds$factors$centroids) %>% 
  rownames_to_column(var = "treatment") %>% 
  mutate(treatment = str_remove(treatment, "treatment"), ordination = "nmds")
colnames(center.nmds) <- c("treatment","center.x","center.y","ordination")

# extract pcoa centroids
center.pcoa <- as.data.frame(fit.pcoa$factors$centroids) %>%
  rownames_to_column(var = "treatment") %>% 
  mutate(treatment = str_remove(treatment, "treatment"), ordination = "pcoa")
colnames(center.pcoa) <- c("treatment","center.x","center.y","ordination")

# cobine 
center.dat <- rbind(center.nmds,center.pcoa)

# add data to ord
ord.tab.2 <- full_join(ord.tab,center.dat)

```

```{r envfit-plot-a, eval=TRUE}

# Create NMDS plot
plot.nmds <- ggplot(ord.tab.2[ord.tab.2$ordination == "nmds",], aes_string(x = "Axis.1", y = "Axis.2", color = VAR)) +
  geom_point() + 
  labs(color=VAR) +
  theme_pubr(legend = "bottom")+
  geom_segment(aes(xend = center.x,yend = center.y)) +
  geom_segment(data = arrow.nmds, 
               aes(x = 0, y = 0, xend = xend, yend = yend, color = NULL), 
               arrow = arrow(type = "closed", length = unit(0.1, "inches")),
               show.legend = FALSE) + 
  geom_text(data = arrow.nmds, 
            aes(x = xend, y = yend, label = row.names(arrow.nmds), color = NULL), 
            nudge_x = 2, nudge_y = 2,
            show.legend = F) +
  ggsci::scale_color_jco()
plot.nmds1 <- plot.nmds + theme_pubr(legend = "none")
plot.nmds2 <- ggExtra::ggMarginal(p = plot.nmds1, type = 'boxplot', size = 10, groupFill = TRUE )

# Create PCoA plot
plot.pcoa <- ggplot(ord.tab.2[ord.tab.2$ordination == "pcoa",], aes_string(x = "Axis.1", y = "Axis.2", color = VAR)) +
  geom_point() + 
  theme_pubr(legend = "none") + 
  labs(color=VAR) +
  geom_segment(aes(xend = center.x,yend = center.y)) +
  geom_segment(aes(x = 0, y = 0, xend = xend, yend = yend, color = NULL), 
               data = arrow.nmds, 
               arrow = arrow(type = "closed", length = unit(0.1, "inches")),
               show.legend = FALSE) + 
  geom_text(data = arrow.nmds, 
            aes(x = xend, y = yend, label = row.names(arrow.nmds), color = NULL), 
            nudge_x = 2, nudge_y = 2,
            show.legend = F) +
  #stat_ellipse() + 
  ggsci::scale_color_jco()
plot.pcoa2 <- ggExtra::ggMarginal(p = plot.pcoa, type = 'boxplot', size = 10, groupFill = TRUE)

# Draw plot
p.done <- ggdraw() + 
  draw_plot(plot.nmds2, 0, 0.1, 0.5, 0.9) + 
  draw_plot(plot.pcoa2, 0.5, 0.1, 0.5, 0.9) +
  draw_grob(plot.legend, 0, 0, 1, .1) +
  draw_plot_label("NMDS") + 
  draw_plot_label("PCoA", x = 0.5) + 
  theme(plot.background = element_rect(fill="white", color = NA))
p.done

# Save plot
plotfile <- file.path("plots",paste0("bdiv_ordination_annotated_",VAR,".png"))
ggsave(filename = plotfile, plot = p.done, width = 14, height = 7,units = "in",dpi = 300)

```

# FINAL COMMENT

This completes the fundamental beta diversity analysis.

If not yet finished, continue with the following steps:

| Analysis               | Template                   | Note                                                               |
|------------------|---------------------|---------------------------------|
| Microbiome description | GMH_description            | Statistical test of sample_data variables, incl alpha diversity    |
| Statistical testing    | GMH_test_variables         | Statistical test and visualization of alpha diversity and metadata |
| Differential abundance | GMH_differential_abundance | Test differential abundance of taxa against sample variables       |

# SETTINGS {.tabset .tabset-fade .tabset-pills}

Overview of the parameters and packages that were used for this Rmarkdown.

## PARAMETERS

The following paramenters were set in for this analysis:

```{r parameters, eval=TRUE}
params <- readRDS( "R_objects/params_betadiv.RDS")


tmp <- unlist(params)
dat <- data.frame(Parameter = names(tmp), Value = unname(tmp))


kbl(dat, row.names = F) %>% kable_classic(lightable_options = "striped")

```

## SESSION INFO

The analysis was run in the following environment:

```{r packages, eval=TRUE}
sessionInfo()
```
