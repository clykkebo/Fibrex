---
title: "Fibrex Microbiome description"
author: "Claus Lykkebo"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    toc_depth: 4
    collapsed: false
    code_folding: hide
    number_sections: false
knit: (function(inputFile, encoding) { 
    rmarkdown::render(
        inputFile, encoding = encoding,
        output_dir = file.path(dirname(inputFile),"output"),
        output_file = paste0("Fibrex_", Sys.Date(), "_Description.html"))
        })
params:
    input: "R_objects/Phyloseq.Rdata"
    group_var: "feed_treat"
    subject_var: "rat_name"
    time_var: "day"
---

# INFO

This template is build to use the output from **GMH_import** as input.
It will generate a general summary of the microbiome for the project, on
all taxonomic levels, followed by a detailed summary where the group and
subject variables is considered in the description.

The output will be observational, containing tables and plots, without
any statistical analyses.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(GMHmicrobiome)
library(ggpubr)
library(kableExtra)
library(phyloseq)

# save parameters
saveRDS(params, "R_objects/params_description.RDS")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

## PROJECT

The FIBREX project is a PFOS exposure experiment focusing on the difference in uptake and wash-out of PFOS between rats given feed with and without dietary fibers. Samples for this analysis are 16S rRNA V3 amplicons from extracted total DNA of feces and luminal samples from ileum and cecum. Fecal samples were collected before exposure start (day 0, n=48) and hereafter at day 8 (n=48), 12 (n=24), 16 (n=24), 20 (n=24) and 21 (n=24). Luminal contents were collected at dissections at day 8 (n=24) and 21 (n=24). DNA was sequenced on IonTorrent platform and raw data converted to ASVs using cutadapt (Martin 2011) and DADA2 (Callahan et al. 2016) and made into Phyloseq elements (McMurdie and Holmes 2013). Goal of the analysis is to investigate the impact of feed, PFOS exposure and time on the gut microbiota.

## VARIABLES

Group variable is set for "feed_treat" which is a combined variable in the format e.g. "LF_CTRL" or "HF_PFOS" grouping based on:
- type of feed (LF = low dietary fiber and HF = high dietary fiber)
- type of treatment given by oral gavage daily for 7 days (CTRL = control with pure corn oil; PFOS = 1.5mg/mL PFOS in corn oil)

Subject variable is set to "rat_name" in the format R01 - R48.

Time variable is set to "day" which includes days of sampling (day 0 = feces before treatment; day 8 = feces directly after treatment from all rats and ileum+cecum from half the rats; day 12 and 16 = 21)

# FORMAT DATA

To describe the data we will have to agglommerate the data to each
taxonomic level. As this is time consuming, the default is to skip this
step if the file "R_objects/Agglomerated.Rdata" does not exist.

```{r format, include=FALSE, eval=FALSE}
# Load data
MTRLS <- c("Feces","Ileum","Cecum")

# Subset
for (MTRL in MTRLS) {
  load(params$input)
  phy <- subset_samples(phy, material == MTRL & day != "d20")
  
  # Update taxa_names
  ### SPECIES
  phy.sp <- tax_glom(phy, taxrank = "Species")
  taxnames <- as.vector(tax_table(phy.sp)[,7])
  taxdub <- taxnames[duplicated(taxnames)]
  for (tax in taxdub){
    taxnames[taxnames == tax] <- paste(tax, seq(length(taxnames[taxnames == tax])), sep = "_")
  }
  taxa_names(phy.sp) <- taxnames
  
  ### GENUS
  phy.ge <- tax_glom(phy, taxrank = "Genus")
  taxnames <- as.vector(tax_table(phy.ge)[,6])
  taxdub <- taxnames[duplicated(taxnames)]
  for (tax in taxdub){
    taxnames[taxnames == tax] <- paste(tax, seq(length(taxnames[taxnames == tax])), sep = "_")
  }
  taxa_names(phy.ge) <- taxnames
  
  ### FAMILY
  phy.fa <- tax_glom(phy, taxrank = "Family")
  taxnames <- as.vector(tax_table(phy.fa)[,5])
  taxdub <- taxnames[duplicated(taxnames)]
  for (tax in taxdub){
    taxnames[taxnames == tax] <- paste(tax, seq(length(taxnames[taxnames == tax])), sep = "_")
  }
  taxa_names(phy.fa) <- taxnames
  
  ### ORDER
  phy.or <- tax_glom(phy, taxrank = "Order")
  taxnames <- as.vector(tax_table(phy.or)[,4])
  taxdub <- taxnames[duplicated(taxnames)]
  for (tax in taxdub){
    taxnames[taxnames == tax] <- paste(tax, seq(length(taxnames[taxnames == tax])), sep = "_")
  }
  taxa_names(phy.or) <- taxnames
  
  ### CLASS
  phy.cl <- tax_glom(phy, taxrank = "Class")
  taxnames <- as.vector(tax_table(phy.cl)[,3])
  taxdub <- taxnames[duplicated(taxnames)]
  for (tax in taxdub){
    taxnames[taxnames == tax] <- paste(tax, seq(length(taxnames[taxnames == tax])), sep = "_")
  }
  taxa_names(phy.cl) <- taxnames
  
  ### PHYLUM
  phy.ph <- tax_glom(phy, taxrank = "Phylum")
  taxnames <- as.vector(tax_table(phy.ph)[,2])
  taxdub <- taxnames[duplicated(taxnames)]
  for (tax in taxdub){
    taxnames[taxnames == tax] <- paste(tax, seq(length(taxnames[taxnames == tax])), sep = "_")
  }
  taxa_names(phy.ph) <- taxnames
  
  # save agglomerated phyloseq objects
  save(phy.sp, phy.ge, phy.fa, phy.or, phy.cl, phy.ph, file = paste0("R_objects/Agglomerated_",MTRL,".RData"))
}
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

# FECES

## OVERALL {.tabset .tabset-dropdown}

This section produces a general description of the data with the plots
grouped by the group_var, but without using any other metadata.

If there are no relevant groups in this part of the analysis it can also
be used to indicate batches. If no groups or batches exist, then please
create a variable that just indicate the project name for all samples.

### PHYLUM {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At phylum level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.ph, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of phyla in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### CLASS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At class level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.cl, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of classes in general and per sample') %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### ORDER {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At order level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.or, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of orders in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### FAMILY {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At family level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.fa, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of families in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order, Family) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### GENUS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At genus level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.ge, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of genera in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order, Family, Genus) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### SPECIES {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At species level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.sp, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of species in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order, Family, Genus, Species) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

## DETAILED {.tabset .tabset-fade .tabset-dropdown}

Many projects contain multiple timepoints and for those it can be
relevant to see data organised by group and time. For the plots in this
part of the script it is required that all parameters set in the header
matches a sample variable. Also, the plots will be created with the
subject_var on the x-axis instead of the sample var, so it is important
that there are no duplicates when combining subject_var and time_var.

### PHYLUM {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At phylum level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.ph)[!is.na(sample_data(phy.ph)[,params$group_var]) & !is.na(sample_data(phy.ph)[,params$time_var])], phy.ph)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of phyla in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var,min.rank = 6,includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa, .keep_all = T)%>% select(Taxa, Kingdom, Phylum) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### CLASS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At class level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.cl)[!is.na(sample_data(phy.cl)[,params$group_var]) & !is.na(sample_data(phy.cl)[,params$time_var])], phy.cl)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of classes in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var,min.rank = 6,includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### ORDER {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At order level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.or)[!is.na(sample_data(phy.or)[,params$group_var]) & !is.na(sample_data(phy.or)[,params$time_var])], phy.or)


# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of orders in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var,min.rank = 6,includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### FAMILY {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At family level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.fa)[!is.na(sample_data(phy.fa)[,params$group_var]) & !is.na(sample_data(phy.fa)[,params$time_var])], phy.fa)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of families in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var, min.rank = 6, includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order,Family) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### GENUS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At genus level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.ge)[!is.na(sample_data(phy.ge)[,params$group_var]) & !is.na(sample_data(phy.ge)[,params$time_var])], phy.ge)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of genera in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var, min.rank = 6, includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(day ~ feed_treat,
             space = "free_x",scales = "free_x",
             labeller = labeller(day = c("d0" = "Day 0", "d08" = "Day 8", "d12" = "Day 12", "d16" = "Day 16", "d20" = "Day 20", "d21" = "Day 21"),
                                 feed_treat = c("HF_CTRL" = "HF-CTRL","HF_PFOS"="HF-PFOS","LF_CTRL"="LF-CTRL","LF_PFOS"="LF-PFOS"))) +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

p.fig <- p + theme_pubr(legend = "right", border = TRUE) + theme(axis.text.x = element_text(angle = 90))

if (!file.exists(paste0("plots/relative_abundance"))) dir.create(file.path(getwd(), paste0("plots/relative_abundance")))
ggsave(filename = "plots/figures/Genus_abundance_faeces.png", plot = p.fig, device = "png", units = "mm", width = 300, height = 185, dpi = 300)
ggsave(filename = "plots/figures/Genus_abundance_faeces.pdf", plot = p.fig, device = "pdf", units = "mm", width = 300, height = 185, dpi = 300)

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order,Family,Genus)  %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### SPECIES {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At species level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Feces.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.sp)[!is.na(sample_data(phy.sp)[,params$group_var]) & !is.na(sample_data(phy.sp)[,params$time_var])], phy.sp)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of species in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var, min.rank = 6, includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order,Family,Genus,Species) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

# ILEUM

## OVERALL {.tabset .tabset-dropdown}

This section produces a general description of the data with the plots
grouped by the group_var, but without using any other metadata.

If there are no relevant groups in this part of the analysis it can also
be used to indicate batches. If no groups or batches exist, then please
create a variable that just indicate the project name for all samples.

### PHYLUM {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At phylum level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.ph, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of phyla in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### CLASS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At class level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.cl, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of classes in general and per sample') %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### ORDER {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At order level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.or, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of orders in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### FAMILY {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At family level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.fa, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of families in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order, Family) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### GENUS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At genus level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.ge, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of genera in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order, Family, Genus) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### SPECIES {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At species level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.sp, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of species in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order, Family, Genus, Species) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

## DETAILED {.tabset .tabset-fade .tabset-dropdown}

Many projects contain multiple timepoints and for those it can be
relevant to see data organised by group and time. For the plots in this
part of the script it is required that all parameters set in the header
matches a sample variable. Also, the plots will be created with the
subject_var on the x-axis instead of the sample var, so it is important
that there are no duplicates when combining subject_var and time_var.

### PHYLUM {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At phylum level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.ph)[!is.na(sample_data(phy.ph)[,params$group_var]) & !is.na(sample_data(phy.ph)[,params$time_var])], phy.ph)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of phyla in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var,min.rank = 6,includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa, .keep_all = T)%>% select(Taxa, Kingdom, Phylum) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### CLASS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At class level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.cl)[!is.na(sample_data(phy.cl)[,params$group_var]) & !is.na(sample_data(phy.cl)[,params$time_var])], phy.cl)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of classes in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var,min.rank = 6,includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### ORDER {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At order level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.or)[!is.na(sample_data(phy.or)[,params$group_var]) & !is.na(sample_data(phy.or)[,params$time_var])], phy.or)


# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of orders in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var,min.rank = 6,includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### FAMILY {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At family level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.fa)[!is.na(sample_data(phy.fa)[,params$group_var]) & !is.na(sample_data(phy.fa)[,params$time_var])], phy.fa)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of families in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var, min.rank = 6, includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order,Family) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### GENUS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At genus level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.ge)[!is.na(sample_data(phy.ge)[,params$group_var]) & !is.na(sample_data(phy.ge)[,params$time_var])], phy.ge)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of genera in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var, min.rank = 6, includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(day ~ feed_treat,
             space = "free_x",scales = "free_x",
             labeller = labeller(day = c("d0" = "Day 0", "d08" = "Day 8", "d12" = "Day 12", "d16" = "Day 16", "d20" = "Day 20", "d21" = "Day 21"),
                                 feed_treat = c("HF_CTRL" = "HF-CTRL","HF_PFOS"="HF-PFOS","LF_CTRL"="LF-CTRL","LF_PFOS"="LF-PFOS"))) +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

p.fig <- p + theme_pubr(legend = "right", border = TRUE) + theme(axis.text.x = element_text(angle = 90))

if (!file.exists(paste0("plots/relative_abundance"))) dir.create(file.path(getwd(), paste0("plots/relative_abundance")))
ggsave(filename = "plots/figures/Genus_abundance_ileum.png", plot = p.fig, device = "png", units = "mm", width = 300, height = 185, dpi = 300)
ggsave(filename = "plots/figures/Genus_abundance_ileum.pdf", plot = p.fig, device = "pdf", units = "mm", width = 300, height = 185, dpi = 300)

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order,Family,Genus)  %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### SPECIES {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At species level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Ileum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.sp)[!is.na(sample_data(phy.sp)[,params$group_var]) & !is.na(sample_data(phy.sp)[,params$time_var])], phy.sp)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of species in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var, min.rank = 6, includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order,Family,Genus,Species) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

# CAECUM

## OVERALL {.tabset .tabset-dropdown}

This section produces a general description of the data with the plots
grouped by the group_var, but without using any other metadata.

If there are no relevant groups in this part of the analysis it can also
be used to indicate batches. If no groups or batches exist, then please
create a variable that just indicate the project name for all samples.

### PHYLUM {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At phylum level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.ph, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of phyla in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### CLASS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At class level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.cl, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of classes in general and per sample') %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### ORDER {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At order level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.or, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of orders in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### FAMILY {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At family level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.fa, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of families in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order, Family) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### GENUS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At genus level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.ge, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of genera in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order, Family, Genus) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### SPECIES {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At species level the microbiome counts are as follows

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Transform data
phy.rel <- transform_sample_counts(phy.sp, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(-Sample, 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff) %>% 
  summarise(sample_mean = mean(Count), 
            sample_sd = sd(Count))

# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU) %>% 
  summarise(Abundance = mean(Abundance)) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>% 
  pivot_longer(cols = everything(), 
               names_to = c("Cutoff"), 
               values_to = "Count")

# Combine
output <- full_join(sumall, sumsample)
output$Cutoff <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of species in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel) %>% filter_rank(min.rank = 19)

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# Create plot
p <- ggplot(dat.sort, aes(x = SampleID,
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(. ~ get(params$group_var),space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% group_by(Taxa, Kingdom, Phylum, Class, Order, Family, Genus, Species) %>% summarise(Abundance = mean(Abundance))


kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

## DETAILED {.tabset .tabset-fade .tabset-dropdown}

Many projects contain multiple timepoints and for those it can be
relevant to see data organised by group and time. For the plots in this
part of the script it is required that all parameters set in the header
matches a sample variable. Also, the plots will be created with the
subject_var on the x-axis instead of the sample var, so it is important
that there are no duplicates when combining subject_var and time_var.

### PHYLUM {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At phylum level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.ph)[!is.na(sample_data(phy.ph)[,params$group_var]) & !is.na(sample_data(phy.ph)[,params$time_var])], phy.ph)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of phyla in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var,min.rank = 6,includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa, .keep_all = T)%>% select(Taxa, Kingdom, Phylum) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### CLASS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At class level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.cl)[!is.na(sample_data(phy.cl)[,params$group_var]) & !is.na(sample_data(phy.cl)[,params$time_var])], phy.cl)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of classes in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var,min.rank = 6,includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### ORDER {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At order level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.or)[!is.na(sample_data(phy.or)[,params$group_var]) & !is.na(sample_data(phy.or)[,params$time_var])], phy.or)


# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of orders in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var,min.rank = 6,includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### FAMILY {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At family level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.fa)[!is.na(sample_data(phy.fa)[,params$group_var]) & !is.na(sample_data(phy.fa)[,params$time_var])], phy.fa)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of families in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var, min.rank = 6, includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order,Family) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### GENUS {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At genus level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.ge)[!is.na(sample_data(phy.ge)[,params$group_var]) & !is.na(sample_data(phy.ge)[,params$time_var])], phy.ge)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of genera in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var, min.rank = 6, includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(day ~ feed_treat,
             space = "free_x",scales = "free_x",
             labeller = labeller(day = c("d0" = "Day 0", "d08" = "Day 8", "d12" = "Day 12", "d16" = "Day 16", "d20" = "Day 20", "d21" = "Day 21"),
                                 feed_treat = c("HF_CTRL" = "HF-CTRL","HF_PFOS"="HF-PFOS","LF_CTRL"="LF-CTRL","LF_PFOS"="LF-PFOS"))) +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

p.fig <- p + theme_pubr(legend = "right", border = TRUE) + theme(axis.text.x = element_text(angle = 90))

if (!file.exists(paste0("plots/relative_abundance"))) dir.create(file.path(getwd(), paste0("plots/relative_abundance")))
ggsave(filename = "plots/figures/Genus_abundance_caecum.png", plot = p.fig, device = "png", units = "mm", width = 300, height = 185, dpi = 300)
ggsave(filename = "plots/figures/Genus_abundance_caecum.pdf", plot = p.fig, device = "pdf", units = "mm", width = 300, height = 185, dpi = 300)

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order,Family,Genus)  %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```

### SPECIES {.tabset .tabset-fade .tabset-pills}

#### COUNTS

At species level the microbiome counts are as follows for each group and
timepoint

```{r, warning=FALSE, message=FALSE}
# load data 
load("R_objects/Agglomerated_Cecum.RData")
params <- readRDS("R_objects/params_description.RDS")

# Remove samples with missing data
phy.use <- prune_samples(sample_names(phy.sp)[!is.na(sample_data(phy.sp)[,params$group_var]) & !is.na(sample_data(phy.sp)[,params$time_var])], phy.sp)

# Transform data
phy.rel <- transform_sample_counts(phy.use, fun = function(x) x/sum(x)*100)
dat <- psmelt(phy.rel)

# summarise per sample
sumsample <- 
  dat %>% 
  filter(Abundance > 0) %>% 
  group_by(Sample, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "Count") %>% 
  group_by(Cutoff, .data[[params$group_var]], .data[[params$time_var]]) %>% 
  summarise(mean = round(mean(Count),2), 
            sd = round(sd(Count),2)) 
  
# summarise total
sumall <- dat %>% 
  filter(Abundance > 0) %>% 
  group_by(OTU, .data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(Abundance = mean(Abundance)) %>%
  group_by(.data[[params$group_var]], .data[[params$time_var]]) %>%
  summarise(pct_0 = n(),
            pct_0.1 = sum(Abundance < 0.1),
            pct_0_1 = sum(Abundance >= 0.1 & Abundance < 1),
            pct_1_10 = sum(Abundance >= 1 & Abundance < 10),
            pct_10 = sum(Abundance > 10)) %>%
  pivot_longer(starts_with("pct"), 
               names_to = c("Cutoff"), 
               values_to = "n")

# Combine
output <- full_join(sumall, sumsample) %>% 
  pivot_wider(id_cols = c(Cutoff, .data[[params$time_var]]), 
              names_from = .data[[params$group_var]],
              values_from = c(n, mean, sd), 
              names_vary = "slowest") %>%
  mutate(Cutoff=factor(Cutoff))


levels(output$Cutoff) <- c("All", "n < 0.1%", "0.1% < n < 1.0%", "1.0% < n < 10%", "10%  < n")

# Create output table
kable(output, row.names = F,digits = 2, caption = 'Count of species in general and per sample',align = "r") %>% 
  kable_classic(full_width = F, position = "left")
                                              
```

#### PLOTS

To improve the interpretation of the compositional plots I will pretreat
the data with three steps:

1.  Filter taxa by average abundance (minimum 1 %) and rank (max 19
    features + "Others")

2.  Sort the plotted taxa by full phylogeny

3.  Change taxa names in plot to a letter and include table of full
    taxonomy

Following this I will incorporate both time_var and subject_var in the
plot

```{r, warning=FALSE, message=FALSE}
# Filter by abundance, then rank
phy.top <- filter_abundance(phy.rel, group = params$group_var,includes = "any") %>% filter_rank(group = params$time_var, min.rank = 6, includes = "any")

#Melt data
dat <- suppressWarnings(psmelt(phy.top))

# Prevent duplicate column names
colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")] <- paste(colnames(dat)[colnames(dat) %in% c("Taxa","SampleID")], "old", sep = "_")

# Rename relevant columns
colnames(dat)[c(1,4)] <- c("Taxa","SampleID")

# Sort taxa
dat.sort <- sort_taxa(dat) 

# rename taxa
levels(dat.sort$Taxa) <- LETTERS[seq(length(levels(dat.sort$Taxa)))]

# ensure that the variables are factors
dat.sort[,params$time_var] <- factor(dat.sort[,params$time_var])
dat.sort[,params$subject_var] <- factor(dat.sort[,params$subject_var])
dat.sort[,params$group_var] <- factor(dat.sort[,params$group_var])

# Create plot
p <- ggplot(dat.sort, aes(x = .data[[params$subject_var]],
                          y = Abundance,
                          fill = Taxa,
                          color = Taxa)) +
  geom_col() +
  xlab("") + 
  facet_grid(get(params$time_var) ~ get(params$group_var),
             space = "free_x",scales = "free_x") +
  ggsci::scale_color_d3(palette = "category20") + 
  ggsci::scale_fill_d3(palette = "category20") + 
  guides(fill=guide_legend(ncol=2), color=guide_legend(ncol=2)) +
  clean_theme()
p

# print tax table
tax <- dat.sort %>% distinct(Taxa,.keep_all = T) %>% select(Taxa, Kingdom, Phylum, Class, Order,Family,Genus,Species) %>% arrange(Taxa)

kable(tax,digits = 2,caption = paste("Taxa plotted", sep = " ")) %>%
  kable_classic(full_width = F, position = "left")

# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())

```



# FINAL COMMENT

This completes the microbiome description.

To begin the statistical analysis of the data you are now ready for the
following steps:

| Analysis               | Template                   | Note                                                               |
|------------------|---------------------|---------------------------------|
| Statistical testing    | GMH_test_variables         | Statistical test and visualization of alpha diversity and metadata |
| Beta diversity         | GMH_beta_diveristy         | Statistical test and visualization of beta diversity               |
| Differential abundance | GMH_differential_abundance | Test differential abundance of taxa against sample variables       |

# SETTINGS {.tabset .tabset-fade .tabset-pills}

Overview of the parameters and packages that were used for this
Rmarkdown.

## PARAMETERS

The following paramenters were set in for this analysis:

```{r parameters, eval=TRUE}
params <- readRDS("R_objects/params_description.RDS")


tmp <- unlist(params)
dat <- data.frame(Parameter = names(tmp), Value = unname(tmp))


kbl(dat, row.names = F) %>% kable_classic(lightable_options = "striped")

```

## SESSION INFO

The analysis was run in the following environment:

```{r packages, eval=TRUE}
sessionInfo()
```
