with(sample_data(phy), table(feed,treatment))
# Evaluate relevant variables
with(sample_data(phy), table(feed,treatment,day))
# Evaluate relevant variables
with(sample_data(phy), table(feed,daytreatment))
# Evaluate relevant variables
with(sample_data(phy), table(feed,day,treatment))
# Remove relevant samples and prune taxa
phy <- subset_samples(phy, type == "Sample")
phy
phy <- prune_taxa(taxa_sums(phy) >=1,phy)
phy
# save the cleaned phyloseq object
save(phy, phy.harsh, file="R_objects/Phyloseq.Rdata")
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
# save the cleaned phyloseq object
save(phy, file="R_objects/Phyloseq.Rdata")
# save the cleaned phyloseq object
save(phy, file="R_objects/Phyloseq.Rdata")
# load data
load("R_objects/Decontam.Rdata")
# Evaluate relevant variables
with(sample_data(phy), table(feed,day,treatment))
# Evaluate relevant variables
with(sample_data(phy), table(feed,day,treatment))
# Remove relevant samples and prune taxa
phy <- subset_samples(phy, type == "Sample")
phy <- prune_taxa(taxa_sums(phy) >=1,phy)
# save the cleaned phyloseq object
save(phy, file="R_objects/Phyloseq.Rdata")
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())
# load
load("R_objects/Phyloseq.Rdata")
load("scripts/adiv.Rdata")
# Set alpha diversity indexes to use
R.methods <- c("Observed", "Chao1", "Shannon", "ACE")
# Look at distribution of sequencing depths
quantile(sample_sums(phy),probs = seq(0,1,0.1))
table(sample_sums(phy) < 10000)
sample_data(phy)[sample_sums(phy) < 10000),]
sample_data(phy)[sample_sums(phy) < 10000,]
sample_data(phy)[sample_sums(phy) < 10000,]
phy <- prune_samples(sample_sums(phy) > 10000, phy)
phy
# Set max depth to the 90th quantile
mdepth <- round(unname(quantile(sample_sums(phy),0.9)))
# calculate rarefaction data
Rdat <- Rcurve_data(phy, methods = R.methods, maxdepth = mdepth)
# clear the environment and release memory
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
invisible(gc()) #free up memory and report the memory usage.
# load
load("R_objects/Phyloseq.Rdata")
load("scripts/adiv.Rdata")
# Set alpha diversity indexes to use
R.methods <- c("Observed", "Chao1", "Shannon", "ACE")
# Look at distribution of sequencing depths
quantile(sample_sums(phy),probs = seq(0,1,0.1))
sample_data(phy)[sample_sums(phy) < 10000,]
# load
load("R_objects/Phyloseq.Rdata")
load("scripts/adiv.Rdata")
# Set alpha diversity indexes to use
R.methods <- c("Observed", "Chao1", "Shannon", "ACE")
# Look at distribution of sequencing depths
quantile(sample_sums(phy),probs = seq(0,1,0.1))
# Set max depth to the 90th quantile
mdepth <- round(unname(quantile(sample_sums(phy),0.9)))
# calculate rarefaction data
Rdat <- Rcurve_data(phy, methods = R.methods, maxdepth = mdepth)
# melt data table
Rdat.m <- reshape2::melt(data = Rdat, id.vars = c(sample_variables(phy), "depth"),measure.vars = R.methods,variable.name = "Index", value.name = "Alpha_diversity")
y
# load data
load("R_objects/Phyloseq.Rdata")
load("scripts/adiv.Rdata")
# Set alpha diversity indexes to use
R.methods <- c("Observed", "Chao1", "Shannon", "ACE")
# Samples to remove
sample_data(phy)[sample_sums(phy) < min.reads,]
# set min reads
min.reads <- 10000
# Samples to remove
sample_data(phy)[sample_sums(phy) < min.reads,]
sample_data(phy)[sample_sums(phy) < min.reads,]
# remove samples based on rarefaction curves
phy <- prune_samples(sample_sums(phy) > 10000, phy)
# Calculate data
adat <- Calculate_alpha_div(phy, methods = R.methods)
# Create a data.frame with and without mock samples
adat.wm <- adat
adat <- adat[adat$type == "Sample",]
# Save the phyloseq object
save(adat, adat.wm, R.methods, file="R_objects/AlphaDiversity.RData")
# clear the environment and release memory
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
invisible(gc()) #free up memory and report the memory usage.
# Load data
load("R_objects/AlphaDiversity.RData")
### Test observed richness
# Run statistical test of batch effect
compare_means(Observed ~ run_plate,  data = adat, method = "kruskal")
compare_means(Observed ~ run_plate,  data = adat, method = "kruskal")
stat.test <- adat %>%
wilcox_test(Observed ~ Run) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_x_position(x = "Run") %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
## If significant:
# Perform pairwise comparisons
stat.test <- adat %>%
wilcox_test(Observed ~ run_plate) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_x_position(x = "Run") %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
# Format for
stat.sig <- stat.test[stat.test$p.adj.signif !="ns",] %>%
add_y_position(step.increase = 0.25) %>%
mutate(y.position = seq(min(y.position), max(y.position),length.out = n()))
# Create plot
p <- ggboxplot(adat, x = "Run", y = "Observed",
color = "Run", palette = "jco",
add = "jitter")
# Create plot
p <- ggboxplot(adat, x = "run_plate", y = "Observed",
color = "run_plate", palette = "jco",
add = "jitter")
p.obs <- p + stat_pvalue_manual(stat.sig, label = "p.adj.format",tip.length = 0)
### Test shannon diversity index
# Run statistical test of batch effect
compare_means(Shannon ~ Run,  data = adat, method = "kruskal")
### Test shannon diversity index
# Run statistical test of batch effect
compare_means(Shannon ~ run_plate,  data = adat, method = "kruskal")
compare_means(Shannon ~ run_plate,  data = adat, method = "kruskal")
## If significant:
# Perform pairwise comparisons
stat.test <- adat %>%
wilcox_test(Shannon ~ Run) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_x_position(x = "Run") %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
## If significant:
# Perform pairwise comparisons
stat.test <- adat %>%
wilcox_test(Shannon ~ run_plate) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_x_position(x = "run_plate") %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
# Format for
stat.sig <- stat.test[stat.test$p.adj.signif !="ns",] %>%
add_y_position(step.increase = 0.25) %>%
mutate(y.position = seq(min(y.position), max(y.position),length.out = n()))
# Create plot
p <- ggboxplot(adat, x = "run_plate", y = "Shannon", color = "run_plate", palette = "jco", add = "jitter")
p.sdi <- p + stat_pvalue_manual(stat.sig, label = "p.adj.format",tip.length = 0)
ggarrange(p.obs,p.sdi, nrow = 1, labels = c("A)","B)"), common.legend = TRUE,legend = "bottom")
## If significant:
# Perform pairwise comparisons
stat.test <- adat %>%
wilcox_test(Observed ~ run_plate) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_x_position(x = "run_plate") %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
# Create plot
p <- ggboxplot(adat, x = "run_plate", y = "Observed",
color = "run_plate", palette = "jco",
add = "jitter")
p.obs <- p + stat_pvalue_manual(stat.sig, label = "p.adj.format",tip.length = 0)
# Format for
stat.sig <- stat.test[stat.test$p.adj.signif !="ns",] %>%
add_y_position(step.increase = 0.25) %>%
mutate(y.position = seq(min(y.position), max(y.position),length.out = n()))
# Create plot
p <- ggboxplot(adat, x = "run_plate", y = "Shannon", color = "run_plate", palette = "jco", add = "jitter")
p.sdi <- p + stat_pvalue_manual(stat.sig, label = "p.adj.format",tip.length = 0)
ggarrange(p.obs,p.sdi, nrow = 1, labels = c("A)","B)"), common.legend = TRUE,legend = "bottom")
# Load data
load("R_objects/AlphaDiversity.RData")
## If significant:
# Perform pairwise comparisons
stat.test <- adat %>%
wilcox_test(Observed ~ run_plate) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_x_position(x = "run_plate") %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
# Format for
stat.sig <- stat.test[stat.test$p.adj.signif !="ns",] %>%
add_y_position(step.increase = 0.25) %>%
mutate(y.position = seq(min(y.position), max(y.position),length.out = n()))
# Create plot
p <- ggboxplot(adat, x = "run_plate", y = "Observed",
color = "run_plate", palette = "jco",
add = "jitter")
p.obs <- p + stat_pvalue_manual(stat.sig, label = "p.adj.format",tip.length = 0)
stat.test <- adat %>%
wilcox_test(Shannon ~ run_plate) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_x_position(x = "run_plate") %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
# Format for
stat.sig <- stat.test[stat.test$p.adj.signif !="ns",] %>%
add_y_position(step.increase = 0.25) %>%
mutate(y.position = seq(min(y.position), max(y.position),length.out = n()))
# Create plot
p <- ggboxplot(adat, x = "run_plate", y = "Shannon", color = "run_plate", palette = "jco", add = "jitter")
p.sdi <- p + stat_pvalue_manual(stat.sig, label = "p.adj.format",tip.length = 0)
# If there is a significant batch effect, then it will be necessary to correct following tests for this effect.
ggarrange(p.obs,p.sdi, nrow = 1, labels = c("A)","B)"), common.legend = TRUE,legend = "bottom")
suppressMessages(ggsave("plots/adiv_batch.pdf"))
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())
load("R_objects/AlphaDiversity.RData")
# Remove samples with incomplete metadata
adat <- adat[!is.na(adat$feed),]
adat$feed_factor <- as.factor(adat$feed)
### Determine if any batch effect might influence your data
# Calculate distribution counts
freq.t <- with(adat, table(run_plate, feed, exclude = NULL))
freq.t
# Determine distribution percentages
prop.table(freq.t,2)*100
# Test if any difference is significant (if not significant the batch effect should be negligible)
chisq_test(freq.t)
chisq_test(freq.t)
compare_means(Observed ~ feed,  data = adat, method = "kruskal")
ggplot(adat, aes(x = as.factor(feed), y = Observed, color = as.factor(feed))) + geom_violin() + geom_jitter()
ggplot(adat, aes(x = as.factor(feed), y = Observed, color = as.factor(feed))) + geom_boxplot() + geom_jitter()
### Determine if any batch effect might influence your data
# Calculate distribution counts
freq.t <- with(adat, table(run+plate, treatment, exclude = NULL))
### Determine if any batch effect might influence your data
# Calculate distribution counts
freq.t <- with(adat, table(run_plate, treatment, exclude = NULL))
freq.t
# Determine distribution percentages
prop.table(freq.t,2)*100
# Test if any difference is significant (if not significant the batch effect should be negligible)
chisq_test(freq.t)
chisq_test(freq.t)
compare_means(Observed ~ treatment,  data = adat, method = "kruskal")
ggplot(adat, aes(x = treatment, y = Observed, color = treatment)) + geom_violin() + geom_jitter()
#### Test project variable
### Observed richness
fit <- aov(Observed ~ feed+treatment, data = adat)
anova(fit)
TukeyHSD(fit)
#### Test project variable
### Observed richness
fit <- aov(Observed ~ treatment+feed, data = adat)
anova(fit)
TukeyHSD(fit)
## Calculate stats for inner variable
# Perform pairwise comparisons
stat.test <- adat %>%
group_by(feed) %>%
wilcox_test(Observed ~ treatment) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_xy_position(x = "feed", dodge = 0.8) %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
## Calculate stats for outer variable
# Perform pairwise comparisons
stat.test2 <- adat %>%
wilcox_test(Observed ~ feed) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_xy_position(x = "feed") %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
# Adjust y value for outer p-values
stat.test2$y.position <- max(stat.test$y.position)*1.1
# Create plot
p <- ggboxplot(adat, x = "feed", y = "Observed",
color = "treatment", palette = "jco",
add = "jitter")
# Add p-values
p.obs <- p + stat_pvalue_manual(stat.test, label = "p.adj.format",tip.length = 0)
p.obs <- p.obs + stat_pvalue_manual(stat.test2, label = "p.adj.format",tip.length = 0.02, step.increase = 0.1)
### Shannon diversity index
fit <- aov(Shannon ~ feed+Outcome2, data = adat)
### Shannon diversity index
fit <- aov(Shannon ~ feed+treatment, data = adat)
anova(fit)
anova(fit)
TukeyHSD(fit)
## Calculate stats for inner variable
# Perform pairwise comparisons
stat.test <- adat %>%
group_by(feed) %>%
wilcox_test(Shannon ~ treatment) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_xy_position(x = "feed", dodge = 0.8) %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
## Calculate stats for outer variable
# Perform pairwise comparisons
stat.test2 <- adat %>%
wilcox_test(Shannon ~ feed) %>%
adjust_pvalue(method = "BH") %>%
add_significance("p.adj") %>%
add_xy_position(x = "feed") %>%
p_format("p.adj", accuracy = 0.0001, trailing.zero = TRUE, new.col = TRUE)
# Adjust y value for outer p-values
stat.test2$y.position <- max(stat.test$y.position)*1.1
# Create plot
p <- ggboxplot(adat, x = "feed", y = "Shannon",
color = "treatment", palette = "jco",
add = "jitter")
# Add p-values
p.sha <- p + stat_pvalue_manual(stat.test, label = "p.adj.format",tip.length = 0)
p.sha <- p.sha + stat_pvalue_manual(stat.test2, label = "p.adj.format",tip.length = 0.02, step.increase = 0.1)
ggarrange(p.obs,p.sha, nrow = 1, labels = c("A)","B)"), common.legend = TRUE,legend = "bottom")
suppressMessages(ggsave("plots/adiv_outcome_week.pdf"))
head(adat)
ggplot(adat, aes(x = day, y = Observed, color = treatment)) + geom_point()
ggplot(adat, aes(x = day, y = Observed, fill = treatment)) + geom_boxplot()
ggplot(adat, aes(x = day, y = Observed, fill = treatment)) + geom_boxplot(group_by(day))
ggplot(adat, aes(x = as.factor(day), y = Observed, color = treatment)) + geom_point()
ggplot(adat, aes(x = as.factor(day), y = Observed, color = treatment)) + geom_boxplot()
ggplot(adat, aes(x = as.factor(day), y = Observed, fill = treatment, color = feed)) + geom_boxplot()
ggplot(adat, aes(x = feed, y = Observed, fill = treatment)) + geom_boxplot() + facet_wrap("day", nrow = 1)
# load
load("R_objects/Phyloseq.Rdata")
# Root tree if necessary
if (!is.rooted(phy_tree(phy))) phy_tree(phy) <- ape::root(phy_tree(phy), sample(taxa_names(phy), 1), resolve.root = TRUE)
# Calculate UniFrac distances
wuf.dist <- UniFrac(phy, weighted = TRUE, parallel = FALSE)
# Calculate PCoA data
wuf.pcoa <- ordinate(phy, method = "PCoA",distance = wuf.dist)
wuf.nmds <- metaMDS(wuf.dist, k = 5, trymax = 100)
# Save distance objects
save(wuf.dist, wuf.nmds, wuf.pcoa, file = "R_objects/WUF.RData")
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())
# load
load("R_objects/Phyloseq.Rdata")
# transform counts
phy.ra <- transform_sample_counts(phy, function(x) x/sum(x))
# Calculate Bray-Curtis dissimilarities
bray.dist <- distance(phy.ra, method = "bray",)
# Calculate PCoA data
bray.pcoa <- ordinate(phy, method = "PCoA",distance = bray.dist)
bray.nmds <- metaMDS(bray.dist, k = 5, trymax = 100)
# Save distance objects
save(bray.dist, bray.nmds, bray.pcoa, file = "R_objects/Bray.RData")
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())
load("R_objects/Phyloseq.Rdata")
load("R_objects/WUF.RData")
# Extract metadata from phyloseq
mdat <- data.frame(sample_data(phy))
# Run PERMANOVA for batch variable
batch.PERM <- adonis2(wuf.dist ~ run_plate, data = mdat)
batch.PERM
# Compare the betadiversity dispertion for the batch variable
batch.bdisp <- betadisper(wuf.dist, mdat$run_plate)
anova(batch.bdisp)
TukeyHSD(batch.bdisp)
plot(batch.bdisp)
run_plate
plot(batch.bdisp)
boxplot(batch.bdisp)
load("R_objects/Bray.RData")
load("R_objects/Bray.RData")
# Extract metadata from phyloseq
mdat <- data.frame(sample_data(phy))
# Run PERMANOVA for batch variable
batch.PERM <- adonis2(bray.dist ~ run_plate, data = mdat)
batch.PERM
# Compare the betadiversity dispertion for the batch variable
batch.bdisp <- betadisper(bray.dist, mdat$run_plate)
anova(batch.bdisp)
plot(batch.bdisp)
plot(batch.bdisp)
boxplot(batch.bdisp)
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())
load("R_objects/Phyloseq.Rdata")
load("R_objects/WUF.RData")
load("R_objects/Bray.RData")
# Extract metadata from phyloseq
mdat <- data.frame(sample_data(phy))
mdat$day_factor <- as.factor(mdat$day)
# Compare the betadiversity dispertion for Weighted UniFrac
wuf.bdisp <- betadisper(wuf.dist, mdat$treatment, bias.adjust=TRUE)
anova(wuf.bdisp)
# Compare the betadiversity dispertion for Weighted UniFrac
wuf.bdisp <- betadisper(wuf.dist, mdat$feed, bias.adjust=TRUE)
anova(wuf.bdisp)
# Compare the betadiversity dispertion for Weighted UniFrac
wuf.bdisp <- betadisper(wuf.dist, mdat$day_factor, bias.adjust=TRUE)
anova(wuf.bdisp)
plot(wuf.bdisp)
plot(wuf.bdisp)
# Test which groups differ (only if the anova test was significant)
(wuf.HSD <- TukeyHSD(wuf.bdisp))
plot(wuf.HSD)
plot(wuf.HSD)
# Run PERMANOVA for Week
(week.wuf <- adonis2(wuf.dist ~ day_factor, data = mdat, permutations = 9999))
(week.bray <- adonis2(bray.dist ~ day_factor, data = mdat, permutations = 9999))
load("R_objects/Phyloseq.Rdata")
load("R_objects/WUF.RData")
load("R_objects/Bray.RData")
# Extract eigen values
wuf.eigen <- wuf.pcoa$values
wuf.eigen$Axis <- as.numeric(row.names(wuf.eigen))
bray.eigen <- bray.pcoa$values
bray.eigen$Axis <- as.numeric(row.names(bray.eigen))
# Create plots for both distance indeces
p.wuf <- ggplot(wuf.eigen[1:10,], aes(x = as.factor(Axis), y = 100*Rel_corr_eig)) +
geom_col(aes(fill = as.factor(Axis))) +
geom_point(aes(x = Axis, y = 100*Cum_corr_eig)) +
geom_line(aes(x = Axis, y = 100*Cum_corr_eig)) +
ylab("Variance explained (%)") +
xlab("Axis") +
ggtitle("Weighted UniFrac") +
theme_pubr(legend = "none")
p.bray <- ggplot(bray.eigen[1:10,], aes(x = as.factor(Axis), y = 100*Rel_corr_eig)) +
geom_col(aes(fill = as.factor(Axis))) +
geom_point(aes(x = Axis, y = 100*Cum_corr_eig)) +
geom_line(aes(x = Axis, y = 100*Cum_corr_eig)) +
ylab("Variance explained (%)") +
xlab("Axis") +
ggtitle("Bray-Curtis") +
theme_pubr(legend = "none")
ggarrange(p.wuf,p.bray, nrow = 1, labels = c("A)","B)"))
suppressMessages(ggsave("plots/bdiv_PCoA_axis.pdf"))
# load data
load("R_objects/Phyloseq.Rdata")
# load data
load("R_objects/Phyloseq.Rdata")
load("R_objects/WUF.RData")
# load data
load("R_objects/Phyloseq.Rdata")
load("R_objects/WUF.RData")
load("R_objects/Bray.RData")
# Create plots of eigenvalues for PCoA plots
wuf.pcoa.tab <- plot_ordination(phy, wuf.pcoa,axes = 1:5,justDF = TRUE)
bray.pcoa.tab <- plot_ordination(phy, bray.pcoa,axes = 1:5,justDF = TRUE)
bray.nmds.tab <- plot_ordination(phy, bray.nmds,axes = 1:5,justDF = TRUE)
# Reformat tables to create one common table
colnames(wuf.nmds.tab)[1:5] <- c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5")
colnames(bray.nmds.tab)[1:5] <- c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5")
wuf.pcoa.tab <- plot_ordination(phy, wuf.pcoa,axes = 1:5,justDF = TRUE)
wuf.nmds.tab <- plot_ordination(phy, wuf.nmds,axes = 1:5,justDF = TRUE)
bray.pcoa.tab <- plot_ordination(phy, bray.pcoa,axes = 1:5,justDF = TRUE)
bray.nmds.tab <- plot_ordination(phy, bray.nmds,axes = 1:5,justDF = TRUE)
# Reformat tables to create one common table
colnames(wuf.nmds.tab)[1:5] <- c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5")
colnames(bray.nmds.tab)[1:5] <- c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5")
wuf.nmds.tab[,c("metric","ordination")] <- rep(c("wuf","nmds"),each = nrow(wuf.nmds.tab))
wuf.pcoa.tab[,c("metric","ordination")] <- rep(c("wuf","pcoa"),each = nrow(wuf.pcoa.tab))
bray.nmds.tab[,c("metric","ordination")] <- rep(c("bray","nmds"),each = nrow(bray.nmds.tab))
bray.pcoa.tab[,c("metric","ordination")] <- rep(c("bray","pcoa"),each = nrow(bray.pcoa.tab))
ord.tab <- rbind(wuf.nmds.tab,wuf.pcoa.tab, bray.nmds.tab, bray.pcoa.tab)
# Melt axis to be in one variable
axis.tab <- melt(ord.tab,
measure.vars = c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5"),
variable.name = "Axis",
value.name = "position")
ggplot(axis.tab, aes(x = metric, y = position, fill = as.factor(Week_clean))) +
geom_boxplot() +
facet_grid(Axis~ordination) +
coord_flip() +
theme_pubr(legend = "bottom")
ggplot(axis.tab, aes(x = metric, y = position, fill = as.factor(day))) +
geom_boxplot() +
facet_grid(Axis~ordination) +
coord_flip() +
theme_pubr(legend = "bottom")
ggplot(axis.tab, aes(x = metric, y = position, fill = feed)) +
geom_boxplot() +
facet_grid(Axis~ordination) +
coord_flip() +
theme_pubr(legend = "bottom")
ggplot(axis.tab, aes(x = metric, y = position, fill = treatment)) +
geom_boxplot() +
facet_grid(Axis~ordination) +
coord_flip() +
theme_pubr(legend = "bottom")
ggplot(axis.tab, aes(x = metric, y = position, fill = feed)) +
geom_boxplot() +
facet_grid(Axis~ordination) +
coord_flip() +
theme_pubr(legend = "bottom")
ggplot(ord.tab, aes(x = Axis.1, y = Axis.2, color = feed)) +
geom_point() +
facet_grid(metric~ordination, scales = "free") +
theme_pubr(legend = "bottom") +
labs(color='Week') +
stat_ellipse()
ggplot(ord.tab, aes(x = Axis.4, y = Axis.2, color = feed)) +
geom_point() +
facet_grid(metric~ordination, scales = "free") +
theme_pubr(legend = "bottom") +
labs(color='feed') +
stat_ellipse()
