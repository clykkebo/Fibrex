bray.pcoa <- ordinate(phy, method = "PCoA",distance = bray.dist)
bray.nmds <- metaMDS(bray.dist, k = 5, trymax = 100)
# Save distance objects
save(bray.dist, bray.nmds, bray.pcoa, file = "R_objects/Bray.RData")
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())
load("R_objects/Phyloseq.Rdata")
load("R_objects/WUF.RData")
# Extract metadata from phyloseq
mdat <- data.frame(sample_data(phy))
# Run PERMANOVA for batch variable
batch.PERM <- adonis2(wuf.dist ~ run_plate, data = mdat)
batch.PERM
# Compare the betadiversity dispertion for the batch variable
batch.bdisp <- betadisper(wuf.dist, mdat$run_plate)
anova(batch.bdisp)
TukeyHSD(batch.bdisp)
plot(batch.bdisp)
run_plate
plot(batch.bdisp)
boxplot(batch.bdisp)
load("R_objects/Bray.RData")
load("R_objects/Bray.RData")
# Extract metadata from phyloseq
mdat <- data.frame(sample_data(phy))
# Run PERMANOVA for batch variable
batch.PERM <- adonis2(bray.dist ~ run_plate, data = mdat)
batch.PERM
# Compare the betadiversity dispertion for the batch variable
batch.bdisp <- betadisper(bray.dist, mdat$run_plate)
anova(batch.bdisp)
plot(batch.bdisp)
plot(batch.bdisp)
boxplot(batch.bdisp)
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())
load("R_objects/Phyloseq.Rdata")
load("R_objects/WUF.RData")
load("R_objects/Bray.RData")
# Extract metadata from phyloseq
mdat <- data.frame(sample_data(phy))
mdat$day_factor <- as.factor(mdat$day)
# Compare the betadiversity dispertion for Weighted UniFrac
wuf.bdisp <- betadisper(wuf.dist, mdat$treatment, bias.adjust=TRUE)
anova(wuf.bdisp)
# Compare the betadiversity dispertion for Weighted UniFrac
wuf.bdisp <- betadisper(wuf.dist, mdat$feed, bias.adjust=TRUE)
anova(wuf.bdisp)
# Compare the betadiversity dispertion for Weighted UniFrac
wuf.bdisp <- betadisper(wuf.dist, mdat$day_factor, bias.adjust=TRUE)
anova(wuf.bdisp)
plot(wuf.bdisp)
plot(wuf.bdisp)
# Test which groups differ (only if the anova test was significant)
(wuf.HSD <- TukeyHSD(wuf.bdisp))
plot(wuf.HSD)
plot(wuf.HSD)
# Run PERMANOVA for Week
(week.wuf <- adonis2(wuf.dist ~ day_factor, data = mdat, permutations = 9999))
(week.bray <- adonis2(bray.dist ~ day_factor, data = mdat, permutations = 9999))
load("R_objects/Phyloseq.Rdata")
load("R_objects/WUF.RData")
load("R_objects/Bray.RData")
# Extract eigen values
wuf.eigen <- wuf.pcoa$values
wuf.eigen$Axis <- as.numeric(row.names(wuf.eigen))
bray.eigen <- bray.pcoa$values
bray.eigen$Axis <- as.numeric(row.names(bray.eigen))
# Create plots for both distance indeces
p.wuf <- ggplot(wuf.eigen[1:10,], aes(x = as.factor(Axis), y = 100*Rel_corr_eig)) +
geom_col(aes(fill = as.factor(Axis))) +
geom_point(aes(x = Axis, y = 100*Cum_corr_eig)) +
geom_line(aes(x = Axis, y = 100*Cum_corr_eig)) +
ylab("Variance explained (%)") +
xlab("Axis") +
ggtitle("Weighted UniFrac") +
theme_pubr(legend = "none")
p.bray <- ggplot(bray.eigen[1:10,], aes(x = as.factor(Axis), y = 100*Rel_corr_eig)) +
geom_col(aes(fill = as.factor(Axis))) +
geom_point(aes(x = Axis, y = 100*Cum_corr_eig)) +
geom_line(aes(x = Axis, y = 100*Cum_corr_eig)) +
ylab("Variance explained (%)") +
xlab("Axis") +
ggtitle("Bray-Curtis") +
theme_pubr(legend = "none")
ggarrange(p.wuf,p.bray, nrow = 1, labels = c("A)","B)"))
suppressMessages(ggsave("plots/bdiv_PCoA_axis.pdf"))
# load data
load("R_objects/Phyloseq.Rdata")
# load data
load("R_objects/Phyloseq.Rdata")
load("R_objects/WUF.RData")
# load data
load("R_objects/Phyloseq.Rdata")
load("R_objects/WUF.RData")
load("R_objects/Bray.RData")
# Create plots of eigenvalues for PCoA plots
wuf.pcoa.tab <- plot_ordination(phy, wuf.pcoa,axes = 1:5,justDF = TRUE)
bray.pcoa.tab <- plot_ordination(phy, bray.pcoa,axes = 1:5,justDF = TRUE)
bray.nmds.tab <- plot_ordination(phy, bray.nmds,axes = 1:5,justDF = TRUE)
# Reformat tables to create one common table
colnames(wuf.nmds.tab)[1:5] <- c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5")
colnames(bray.nmds.tab)[1:5] <- c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5")
wuf.pcoa.tab <- plot_ordination(phy, wuf.pcoa,axes = 1:5,justDF = TRUE)
wuf.nmds.tab <- plot_ordination(phy, wuf.nmds,axes = 1:5,justDF = TRUE)
bray.pcoa.tab <- plot_ordination(phy, bray.pcoa,axes = 1:5,justDF = TRUE)
bray.nmds.tab <- plot_ordination(phy, bray.nmds,axes = 1:5,justDF = TRUE)
# Reformat tables to create one common table
colnames(wuf.nmds.tab)[1:5] <- c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5")
colnames(bray.nmds.tab)[1:5] <- c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5")
wuf.nmds.tab[,c("metric","ordination")] <- rep(c("wuf","nmds"),each = nrow(wuf.nmds.tab))
wuf.pcoa.tab[,c("metric","ordination")] <- rep(c("wuf","pcoa"),each = nrow(wuf.pcoa.tab))
bray.nmds.tab[,c("metric","ordination")] <- rep(c("bray","nmds"),each = nrow(bray.nmds.tab))
bray.pcoa.tab[,c("metric","ordination")] <- rep(c("bray","pcoa"),each = nrow(bray.pcoa.tab))
ord.tab <- rbind(wuf.nmds.tab,wuf.pcoa.tab, bray.nmds.tab, bray.pcoa.tab)
# Melt axis to be in one variable
axis.tab <- melt(ord.tab,
measure.vars = c("Axis.1","Axis.2","Axis.3","Axis.4","Axis.5"),
variable.name = "Axis",
value.name = "position")
ggplot(axis.tab, aes(x = metric, y = position, fill = as.factor(Week_clean))) +
geom_boxplot() +
facet_grid(Axis~ordination) +
coord_flip() +
theme_pubr(legend = "bottom")
ggplot(axis.tab, aes(x = metric, y = position, fill = as.factor(day))) +
geom_boxplot() +
facet_grid(Axis~ordination) +
coord_flip() +
theme_pubr(legend = "bottom")
ggplot(axis.tab, aes(x = metric, y = position, fill = feed)) +
geom_boxplot() +
facet_grid(Axis~ordination) +
coord_flip() +
theme_pubr(legend = "bottom")
ggplot(axis.tab, aes(x = metric, y = position, fill = treatment)) +
geom_boxplot() +
facet_grid(Axis~ordination) +
coord_flip() +
theme_pubr(legend = "bottom")
ggplot(axis.tab, aes(x = metric, y = position, fill = feed)) +
geom_boxplot() +
facet_grid(Axis~ordination) +
coord_flip() +
theme_pubr(legend = "bottom")
ggplot(ord.tab, aes(x = Axis.1, y = Axis.2, color = feed)) +
geom_point() +
facet_grid(metric~ordination, scales = "free") +
theme_pubr(legend = "bottom") +
labs(color='Week') +
stat_ellipse()
ggplot(ord.tab, aes(x = Axis.4, y = Axis.2, color = feed)) +
geom_point() +
facet_grid(metric~ordination, scales = "free") +
theme_pubr(legend = "bottom") +
labs(color='feed') +
stat_ellipse()
# Load libraries
knitr::opts_chunk$set(echo = TRUE)
suppressWarnings(library(tidyverse))
suppressWarnings(library(phyloseq))
suppressWarnings(library(decontam))
suppressWarnings(library(pals))
suppressWarnings(library(ggpubr))
suppressWarnings(library(rstatix))
suppressWarnings(library(vegan))
suppressWarnings(library(reshape2))
suppressWarnings(library(DAtest))
suppressWarnings(library(ape))
# Print package versions
cat("PACKAGES USED IN THIS PIPELINE:\n",
"tidyverse:", as.character(packageVersion("tidyverse")), "|",
"phyloseq:", as.character(packageVersion("phyloseq")), "|",
"reshape2:", as.character(packageVersion("reshape2")), "|",
"decontam:", as.character(packageVersion("decontam")), "\n",
"DAtest:", as.character(packageVersion("DAtest")), "|",
"pals:", as.character(packageVersion("pals")), "|",
"ggpubr:", as.character(packageVersion("ggpubr")), "|",
"rstatix:", as.character(packageVersion("rstatix")), "|",
"ape:", as.character(packageVersion("ape")), "|",
"vegan", as.character(packageVersion("vegan")), "\n")
# Create used folders if missing
if (!file.exists("R_objects")) dir.create(file.path(getwd(), "R_objects"))
if (!file.exists("plots")) dir.create(file.path(getwd(), "plots"))
if (!file.exists("tables")) dir.create(file.path(getwd(), "tables"))
clean_taxa <- function(physeq, tax_remove = "Phylum", verbose = TRUE) {
tax <- data.frame(tax_table(physeq))
# list ASVs that should be removed
remove <- is.na(tax[,tax_remove])
# remove ASVs
phy.out <- prune_taxa(!remove, physeq)
# Calculate and print statistics
if (verbose) {
# Calculate sample sums of original and cleaned
output <- data.frame(row.names = sample_names(physeq),
org = sample_sums(physeq),
cleaned = sample_sums(phy.out))
output$removed <- output$org - output$cleaned
output$prc_removed <- output$removed*100/output$org
# Print output
cat("OVERVIEW OF ASVs REMOVED:\n",
"Removed ASVs (%):\t",
sum(remove),
" (",
round(sum(remove)*100/nrow(tax), digits = 3),
")\n",
"Removed reads (%):\t",
sum(output$removed),
" (",
round(sum(output$removed)*100/sum(output$org), digits = 3),
")\n",
"Mean abundance removed:\t",
round(mean(output$prc_removed), digits = 3),"\n",
"Max abundance removed:\t",
round(max(output$prc_removed), digits = 3),"\n", sep = "")
}
# Remove NA from tax table
tax <- data.frame(tax_table(phy.out))
for (i in seq(nrow(tax))) {
if (is.na(tax[i,1])) {tax[i,1:7] <- "Unknown"
} else if (is.na(tax[i,2])) {tax[i,2:7] <- paste(colnames(tax)[1],tax[i,1], sep = "_")
} else if (is.na(tax[i,3])) {tax[i,3:7] <- paste(colnames(tax)[2],tax[i,2], sep = "_")
} else if (is.na(tax[i,4])) {tax[i,4:7] <- paste(colnames(tax)[3],tax[i,3], sep = "_")
} else if (is.na(tax[i,5])) {tax[i,5:7] <- paste(colnames(tax)[4],tax[i,4], sep = "_")
} else if (is.na(tax[i,6])) {tax[i,6:7] <- paste(colnames(tax)[5],tax[i,5], sep = "_")
} else if (is.na(tax[i,7])) {tax[i,7] <- paste(colnames(tax)[6],tax[i,6], sep = "_")
}
}
# Insert modified tax_table in phyloseq object
tax_table(phy.out) <- as.matrix(tax)
# return the clean phyloseq object
return(phy.out)
}
# Save function
save(clean_taxa, file = "scripts/clean_tax.Rdata")
# clear the environment and release memory
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
invisible(gc()) #free up memory and report the memory usage.
# Rarefaction curves
Rcurve_data <- function(physeq, ntables=10, step=250,maxdepth = max(sample_sums(physeq)), methods=c("Observed","Chao1","ACE","Shannon"), seedstart=500, verbose=FALSE) {
require("vegan")
# prep list of
step.seq <- seq(from = 1, to = maxdepth, by = step)
# Calculate alpha diversity
rare_tab <- lapply(step.seq,function(k) Calculate_alpha_div(physeq = physeq, ntables = ntables, depth = k, methods = methods, seedstart = seedstart, verbose = verbose))
# Format table
rare_tab <- do.call(rbind, rare_tab)
return(rare_tab)
}
# Calculate alpha diversity
Calculate_alpha_div <- function(physeq, ntables=100, depth = round(min(sample_sums(physeq))*0.9), methods=c("Observed","Chao1","ACE","Shannon"), seedstart=500, verbose=FALSE) {
require("vegan")
# remove samples below depth
phy.use <- prune_samples(sample_sums(physeq) >= depth, physeq )
# Orientate the OTU correctly
if (taxa_are_rows(phy.use)){otu.tab<-unclass(t(otu_table(phy.use)))} else otu.tab <- unclass(otu_table(phy.use))
# Rarefaction function
rarefy <- function(x, depth) {
y <- sample(rep(1:length(x), x), depth)
y.tab <- table(y)
j <- numeric(length(x))
j[as.numeric(names(y.tab))] <- y.tab
j
}
# Table to output alpha diversity table
Alpha_diversity = data.frame(row.names = row.names(otu.tab))
for (i in seq(length(methods))){
Alpha_diversity[,methods[i]] <- numeric(length = nrow(otu.tab))
Alpha_diversity[,paste0(methods[i],"_sd")] <- numeric(length = nrow(otu.tab))
}
# Run each sample separately
for (z in 1:nrow(otu.tab)) {
if (verbose==TRUE) {
print(paste("Rarefaction sample number", z, sep=" "))
}
numbers <- otu.tab[z,]
# Rarefy the sample ntables times
set.seed(seedstart + z)
rare_tab <- lapply(1:ntables,function(k) rarefy(numbers,depth))
# Format table
rare_tab <- do.call(rbind, rare_tab)
# Calculate Observed richness, Chao1, and ACE.
adiv <- data.frame(t(estimateR(rare_tab)))
if ("Observed" %in% methods){
# Save mean and sd of observed richness
Alpha_diversity$Observed[z] <- mean(adiv$S.obs)
Alpha_diversity$Observed_sd[z] <- sd(adiv$S.obs)
}
if ("Chao1" %in% methods){
# Save mean and sd of observed richness
Alpha_diversity$Chao1[z] <- mean(adiv$S.chao1)
Alpha_diversity$Chao1_sd[z] <- sd(adiv$S.chao1)
}
if ("ACE" %in% methods){
# Save mean and sd of observed richness
Alpha_diversity$ACE[z] <- mean(adiv$se.ACE)
Alpha_diversity$ACE_sd[z] <- sd(adiv$se.ACE)
}
if ("Shannon" %in% methods){
# Calculate observed richness for each rep of sample z
adiv <- diversity(rare_tab, index = "shannon")
# Save mean and sd of observed richness
Alpha_diversity$Shannon[z] <- mean(adiv)
Alpha_diversity$Shannon_sd[z] <- sd(adiv)
}
if ("Simpson" %in% methods){
# Calculate observed richness for each rep of sample z
adiv <- diversity(rare_tab, index = "simpson")
# Save mean and sd of observed richness
Alpha_diversity$Simpson[z] <- mean(adiv)
Alpha_diversity$Simpson_sd[z] <- sd(adiv)
}
if ("Evenness" %in% methods){
# Calculate observed richness for each rep of sample z
sha <- diversity(rare_tab, index = "shannon")
obs <- rowSums(rare_tab != 0)
adiv <- sha/log(obs)
# Save mean and sd of observed richness
Alpha_diversity$Evenness[z] <- mean(adiv)
Alpha_diversity$Evenness_sd[z] <- sd(adiv)
}
}
# Add alpha diversity to sample data
output <- cbind(sample_data(phy.use),Alpha_diversity)
output$depth = depth
# Return physeq to the environment
return(output)
}
# save functions
save(Calculate_alpha_div, Rcurve_data, file = "scripts/adiv.Rdata")
# clear the environment and release memory
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
invisible(gc()) #free up memory and report the memory usage.
# Load analysis data
load("output/fibrex.merged.phyloseq_object.RData")
# Create sample ID variable and use it as sample_names
sample_data(phy)$ID <- sample_names(phy)
# Create variables identifying negative controls. If negative controls are named differently update this option, "|" can be used to list more options
sample_data(phy)$is.neg <- grepl("WTR",sample_data(phy)$ID,ignore.case = TRUE)
# Create variables identifying sample types.Remember to update if Mock samples samples are named differently
sample_data(phy)$type <- ifelse(sample_data(phy)$is.neg, "Control",
ifelse(grepl("Mock",sample_data(phy)$ID,
ignore.case = TRUE), "Mock","Sample"))
# Create backup of the original dataset
phy.org <- phy
# export sample data
tmp <- data.frame(sample_data(phy))
# Load metadata - This part will be specific to the project
meta <- read.csv("metadata.csv", header = T)
meta$sampleID[grepl("MOCK",meta$sampleID)] <- str_replace(meta$sampleID[grepl("MOCK",meta$sampleID)], "MOCK","Mock")
# Verify that all the IDs are identical between the datasets
nrow(tmp[!tmp$ID %in% meta$sampleID,])
nrow(meta[!meta$sampleID %in% tmp$ID,])
# Check which, if any columns, are in both tables
colnames(tmp)[colnames(tmp) %in% colnames(meta)]
# If any other columns than ID is in both, consider if you want it removed or renamed
colnames(meta)[which(colnames(meta) == "type")] <- "material"
# When you are sure that all match, then merge and add to phyloseq
mtmp <- merge(tmp,meta,by.x="ID",by.y = "sampleID", all.x = TRUE, all.y = FALSE)
row.names(mtmp) <- mtmp$ID
# Add the merged data to the phyloseq object
sample_data(phy) <- mtmp
# Save the phyloseq object
save(phy.org, phy, file="R_objects/input.Rdata")
# clear the environment and release memory
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
invisible(gc()) #free up memory and report the memory usage.
################################################################################
# load data
load("R_objects/input.Rdata")
# Load function
load("scripts/clean_tax.Rdata")
# Clean phyloseq object
phy <- clean_taxa(phy, tax_remove = "Phylum", verbose = TRUE)
# Save cleaned phyloseq object
save(phy.org, phy, file="R_objects/cleaned.Rdata")
# clear the environment and release memory
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
invisible(gc()) #free up memory and report the memory usage.
################################################################################
# load data
load("R_objects/cleaned.Rdata")
### If using prevalence based method
# Compare sequencing depth to sample type
df <- data.frame(sample_data(phy))
df <- df[order(df$reads),]
df$Index <- seq(nrow(df))
ggplot(data=df, aes(x=Index, y=reads, color=type)) + geom_point()
suppressMessages(ggsave("plots/sequencing_depth.pdf"))
# use prevalence method to decontam
contamdf <- isContaminant(phy, method="prevalence", neg="is.neg")
table(contamdf$contaminant)
################################################################################
# plot presence Abundance of contaminants
ps.prc <- transform_sample_counts(phy, function(x) 100*x/sum(x))
prc.melt <- psmelt(ps.prc)
prc.melt$contaminant <- prc.melt$OTU %in% row.names(contamdf)[contamdf$contaminant]
contam.prc <- aggregate(Abundance~Sample+type+contaminant, data = prc.melt, FUN = sum)
ggplot(contam.prc[contam.prc$contaminant,], aes(x = type, y = Abundance)) + geom_boxplot()
suppressMessages(ggsave("plots/contaminant_fraction_single.pdf"))
aggregate(Abundance~type+contaminant, data = contam.prc, FUN = mean)
# Create and store table of taxa and their abundance
tax.df <- aggregate(Abundance ~ OTU+Phylum+Class+Order+Family+Genus+Species+type+contaminant, data = prc.melt, FUN = mean)
tmp <- reshape2::dcast(tax.df,formula = Phylum+Class+Order+Family+Genus+Species+OTU+contaminant~type, value.var = "Abundance")
write.table(tmp, file = "tables/contaminant_taxa.tsv", row.names = F,quote = F, sep = "\t",col.names = T)
# Evaluate what you can agree to loose, I will use the default
phy <- prune_taxa(row.names(contamdf)[!contamdf$contaminant], phy)
# Filter ASVs with less than 5 reads
phy <- prune_taxa(taxa_sums(phy) >= 5,phy)
# Plot depth v type again
df <- data.frame(sample_data(phy))
df$depth <- sample_sums(phy)
df <- df[order(df$depth),]
df$Index <- seq(nrow(df))
ggplot(data=df, aes(x=Index, y=depth, color=type)) + geom_point()
# save the cleaned phyloseq object
save(phy, file="R_objects/Decontam.Rdata")
# clear the environment and release memory
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
invisible(gc()) #free up memory and report the memory usage.
# load data
load("R_objects/cleaned.Rdata")
# Compare sequencing depth to sample type
df <- data.frame(sample_data(phy))
df <- df[order(df$reads),]
df$Index <- seq(nrow(df))
ggplot(data=df, aes(x=Index, y=reads, color=type)) + geom_point()
suppressMessages(ggsave("plots/sequencing_depth.pdf"))
# Prep table for output
contam.df <- data.frame(row.names = taxa_names(phy))
# Set any sample with DNA below detection limit (or neg PCR controls) to half the lowest measured value
sample_data(phy)$quant_reading <- ifelse(sample_data(phy)$dna_conc == 0, min(sample_data(phy)$dna_conc[sample_data(phy)$dna_conc != 0])/2, sample_data(phy)$dna_conc)
# Both methods, no batches
contam.df$Prev.none <- isContaminant(phy, method="prevalence", neg="is.neg", detailed = FALSE)
contam.df$Freq.none <- isContaminant(phy, method="frequency", conc="quant_reading", detailed = FALSE)
# load data
load("R_objects/Decontam.Rdata")
# Subset mocks
mocks <- subset_samples(phy, type == "Mock")
mocks <- prune_taxa(taxa_sums(mocks) >= 5, mocks)
# Control for depth of mocks
table(sample_sums(mocks))
# All fine, so transform to percentages
mocks.prc <- transform_sample_counts(mocks,fun = function(x) x*100/sum(x))
# Define original mock
mock.org <- data.frame(Sample = "Original",Abundance = 5, Family_clean = c("Moraxellaceae", "Actinomycetaceae", "Bacillaceae_1", "Bacteroidaceae", "Clostridiaceae_1", "Deinococcaceae", "Enterococcaceae", "Enterobacteriaceae", "Helicobacteraceae", "Lactobacillaceae", "Listeriaceae", "Neisseriaceae", "Propionibacteriaceae", "Pseudomonadaceae", "Rhodobacteraceae", "Staphylococcaceae", "Staphylococcaceae", "Streptococcaceae", "Streptococcaceae", "Streptococcaceae"))
# Define anything not matching orginal mock families as NA
mock <- psmelt(mocks.prc)
mock <- mock[mock$Abundance > 0,]
mock$Family_clean <- ifelse(mock$Family %in% mock.org$Family_clean, mock$Family, NA)
# melt mocks
mock.clean <- mock[,c("Sample","Abundance","Family_clean")]
mock.clean <- rbind(mock.clean,mock.org)
# Create plots
ggplot(mock.clean, aes(Sample, Abundance, fill = Family_clean, color = Family_clean)) +
geom_col(position = "fill") + coord_flip() +
scale_fill_manual(values=unname(pals::polychrome(n=length(unique(mock.clean$Family_clean))))) +
scale_color_manual(values=unname(pals::polychrome(n=length(unique(mock.clean$Family_clean)))))
suppressMessages(ggsave("plots/mock_comparison.pdf"))
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())
# load data
load("R_objects/Decontam.Rdata")
# Evaluate relevant variables
with(sample_data(phy), table(feed,day,treatment))
# Remove relevant samples and prune taxa
phy <- subset_samples(phy, type == "Sample")
phy <- prune_taxa(taxa_sums(phy) >=1,phy)
# save the cleaned phyloseq object
save(phy, file="R_objects/Phyloseq.Rdata")
# clear the environment and release memory
rm(list = ls(all.names = TRUE))
invisible(gc())
# load
load("R_objects/Phyloseq.Rdata")
load("scripts/adiv.Rdata")
# Set alpha diversity indexes to use
R.methods <- c("Observed", "Chao1", "Shannon", "ACE")
# Look at distribution of sequencing depths
quantile(sample_sums(phy),probs = seq(0,1,0.1))
# Set max depth to the 90th quantile
mdepth <- round(unname(quantile(sample_sums(phy),0.9)))
# calculate rarefaction data
Rdat <- Rcurve_data(phy, methods = R.methods, maxdepth = mdepth)
# melt data table
Rdat.m <- reshape2::melt(data = Rdat, id.vars = c(sample_variables(phy), "depth"),measure.vars = R.methods,variable.name = "Index", value.name = "Alpha_diversity")
Rdat.m$Alpha_diversity[Rdat.m$Alpha_diversity == "NaN"] <- 1
# save Rdat
save(Rdat.m, file = "R_objects/Rare_dat.RData")
# clear the environment and release memory
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
invisible(gc()) #free up memory and report the memory usage.
# Load data
load("R_objects/Rare_dat.RData")
# plot per sample
ggplot(Rdat.m, aes(x = depth, y = Alpha_diversity, color = Run)) +
geom_smooth(aes(group = Sample), se = FALSE) +
facet_wrap("Index", scales = "free") +
#scale_x_log10() +
theme_pubclean()
# Load data
load("R_objects/Rare_dat.RData")
# plot per sample
ggplot(Rdat.m, aes(x = depth, y = Alpha_diversity, color = plate_run)) +
geom_smooth(aes(group = Sample), se = FALSE) +
facet_wrap("Index", scales = "free") +
#scale_x_log10() +
theme_pubclean()
View(Rdat.m)
